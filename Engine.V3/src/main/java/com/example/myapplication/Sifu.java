package com.example.myapplication;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;

public class Sifu extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_sifu);
    }
    // сначала попробоват реализовать простую логику
         /*Выходной параметр это L - это S.Alfa_Old, который сравнивается с L#-текущее (S.Alfa) и по (результату)
      которому задается IDV - |Id| (по модулю)*/
     // что она будет делать - на вход прнимат паремтр, как по функционалке, максимум приблизится к функционалке- ЭТО главное
    /*
    * Входная часть в регуляторе тока  OuRegS = OuRegS_dop_kod ; !!!!!!RT.c
      "Id#-текущее   ", &OuRegS_dop_kod
    *либо
    * "Id#       ",  &OuRegS_dop_kod,
    * далее
    * OuRegS =- такой переменно для индикации нет
    * ============================================================================================
    * далее ограничение
              if ((sw)OuRegS < (sw)_r.OuRSMaxMost2 ) OuRegS = _r.OuRSMaxMost2 , Prz._.int_m = 1 ;
        }
      "Id#-макс1P    ", &_r.OuRSMaxMost1
    { "Id#-макс1M    ", &_r.OuRSMaxMost2
===================================================================================================
      IDN1 = IDN;
      ZIDN1 = ZIDN;
далее перекладывается в
      "|Id#R|    ",  &ZIDN
    * ZIDN =  OuRegS; // задание тока однополярное , взято по модулю
    *======================================================================
    * Далее через задание интенсивности
    *  if ( ZIDN >= ZIDN1 )
       {
          bx = ZIDN - ZIDN1  ;
          if ( bx > _r.Temp_RT_P )  ZIDN = ZIDN1 + _r.Temp_RT_P ;
       }
       else
       {
          bx = ZIDN1 - ZIDN  ;
          if ( bx > _r.Temp_RT_M )  ZIDN = ZIDN1 - _r.Temp_RT_M ;
       }
    *где
    *  { "ТемпЗИ-РТ'+'  ", &_r.Temp_RT_P         ,_Id_nom( 0.0 )   ,_Id_nom( 2.0 )    , _K_diskr     ,(w*)&_ind_Nom, _Id_nom( 0.01 ), 0xff, "­®¬", _form(1,4,0,2) },
    {    "ТемпЗИ-РТ'-'  ", &_r.Temp_RT_M
    *
    * ======================================================================
    * далее идет расчет
    * INN = (w) ( lax >> 8 ) ; // гранично - непрерывный ток - пересчитанный с учетом ЭДС
    *{ "INN  , INN-дв ", { &INN            , &INN_dvig
    *===============================================================================================
    * // DAN 24.11.2016 - .гранично - непрерывный ток для двигателя наступает раньше чем гранично непрерывный в мосту.
      lax = (lw)_or.INN0_dvig * (lw)bx  ;
      INN_dvig = (w) ( lax >> 8 ) ;

      где
      #ifdef  _SIFU2_
    { "Id-гр-непр-дв ", &_or.INN0_dvig        ,_Id_nom( 0.0 )   ,_Id_nom( 2.0 )    ,_Id_Nom       ,(w*)&_ind_Nom,  1*_K_diskr    , 0xff, "­®¬", _form(1,2,3,2) },
    { "Коэфф-INN     ", &_or.KINN             , 0x0050          , 0x0125           , 0x0100       ,(w*)&_ind_Nom,  1             , 0xff, "¥¤" , _form(1,2,3,2) },
#endif


=[==================================================================================================
    ** Далее через задание интенсивности
    *  if ( ZIDN >= ZIDN1 )
       {
          bx = ZIDN - ZIDN1  ;
          if ( bx > _r.Temp_RT_P )  ZIDN = ZIDN1 + _r.Temp_RT_P ;
       }
       else
       {
          bx = ZIDN1 - ZIDN  ;
          if ( bx > _r.Temp_RT_M )  ZIDN = ZIDN1 - _r.Temp_RT_M ;
       }
    *где
    *  { "ТемпЗИ-РТ'+'  ", &_r.Temp_RT_P         ,_Id_nom( 0.0 )   ,_Id_nom( 2.0 )    , _K_diskr     ,(w*)&_ind_Nom, _Id_nom( 0.01 ), 0xff, "­®¬", _form(1,4,0,2) },
    {    "ТемпЗИ-РТ'-'  ", &_r.Temp_RT_M
    *

    *===============================================================================================
    * далее
    * ax = IDV ;
    *  "|Id1|, Id1s   ", { &IDV            , &Id_sr
    *  ============================================================================================
    *  далее #ifndef _KTEV
      if  ( IDN < (INN - INN/6 )) IDN = ax ;
      else if  ( ax < IDN )       IDN = ax ;
      else                        IDN = ax + (w)( (lw)( ax - IDN ) * (w)_r.KRTDI >> 8 ) ;
      //if ( FSIFU.DIO == 0 ) OIRT1 = OIRT ;
#else
      IDN = ax ; // 22.02.2008 8:37 -для КТЕВа не нужен динамический коэф.
#endif
где
"РТи-p, Id-p   ", { &OIRT           , &IDN


====================================================================================================
далее непонятные для меня действия
if ( S.flg._.Fdmin == 0 ) OIRT1 = OIRT ;
      else
          {
            if ( ZIDN1 > IDN )   // и если на прошлом пульсе был Fdmin==1 производим перерасчет интегратора
              {
                 bx = ( ZIDN1 - IDN ) / 2 ;
                 if ( bx > (10*_K_diskr) ) bx = 10*_K_diskr ;

                 tst1 = 1 ;
                 goto ri  ;  // идет на перерасчет интегратора

                // lax = (lw) bx * (lw)KRTI ;
                // if ( lax > 0x0f00u )  lax = 0x0f00u  ;
                // OIRT = OIRT + (w) lax  ;
                // if ( ( OIRT > 0x4000u) || (OIRT > _r.RTMAX ) )  OIRT = _r.RTMAX ;

         ri_ok:              // перерасчет интегратора окончен
                 tst1 = 0 ;
                 OIRT1 = OIRT ;
              }

          }
где  { "РТи-p, Id-p   ", { &OIRT           , &IDN
-------------------------------------------=======================================================
даллее
#ifndef _KTEV
  #ifdef  _SIFU2_
      // 13.06.2018 13:15 - Шестаков сказал , что для 12-ти пульсных сделать возможность изменения :
      if ( ( ZIDN1 >= INN ) && ( IDN > (sw)((slw)(sw)INN * (slw)(sw)_or.KINN >> 8)) ) //_or.KINN = 0.8
  #else
      if ( ( ZIDN1 >= INN ) && ( IDN > ( INN - INN / 5 )) )
  #endif
        {
          tst2 = 0 ;
          if (ZIDN < INN )
            {
              if  ( INN <= (3*_K_diskr) )  // 16.11.06  ZIDN = 1 ;
              {      // 16.11.06 пока ZIDN не нуль, делаем кк и делали "ZIDN=1",
                if  ( ZIDN != 0 )  ZIDN = 1*_K_diskr ; // а в остальном пропускаем "0".
              }
              else              ZIDN = INN - (3*_K_diskr) ;
            }

        }
      else
        {
          tst2 = 1 ;
          if ( ZIDN >= INN )
            {
                 ZIDN = INN + INN / 15 + (1*_K_diskr) ;
            }
        }
      //01.03.2017 - Коэффициенты РТ берутся из двух мест - из уставки или рассчитываются АН :
      if  ( tst2 == 0 )  KRTI = _r_KRTNI;  //_r.KRTNI;    - Ти для непрерыного тока .
      else               KRTI = _r_KRTPRI; //_r.KRTPRI;   - Ти для прерывистого тока .
#else
      tst2 = 0 ; // Заглушка для компилятора .
      KRTI = _r.KRTNI; // 22.02.2008 8:37 - для КТЭВа не нужно хитрое обрезание задания и
                       //                   прерывистый коэффициент .
#endif

где
для 12-ти пульсной

#ifdef  _SIFU2_
    { "Id-гр-непp-дв ", &_or.INN0_dvig        ,_Id_nom( 0.0 )   ,_Id_nom( 2.0 )    ,_Id_Nom       ,(w*)&_ind_Nom,  1*_K_diskr    , 0xff, "ном", _form(1,2,3,2) },
    { "Коэфф-INN     ", &_or.KINN             , 0x0050          , 0x0125           , 0x0100       ,(w*)&_ind_Nom,  1             , 0xff, "ед" , _form(1,2,3,2) },
#endif

  { "|Id#R|, |Id|  ", { &ZIDN           , &IDV

  "'Kп-РТ        ", &_r_KRTP              , 0               , 127*256          , 256          ,(w*)&_ind_Nom,  0             , 0xff, "ед" , _form(1,3,2,2) },
    { "'Kп-РТ-AH     ", &an_KRTP              , 0               , 127*256          , 256          ,(w*)&_ind_Nom,  0             , 0xff, "ед" , _form(1,3,2,2) },
    { "Kп-РТ-уст     ", &_r.KRTP              , 0               , 127*256          , 256          ,(w*)&_ind_Nom,  4             , 0xff, "ед" , _form(1,3,2,2) },
    { "'Ти-РТпреp    ", &_r_KRTPRI            , 0               , (sw)0xFFFFu      , 64           ,(w*)&_ind_Nom,  0             , 0xff, "мceк",_form(1,3,2,2) },
    { "'Ти-РТпреp-AH ", &an_KRTPRI            , 0               , (sw)0xFFFFu      , 64           ,(w*)&_ind_Nom,  0             , 0xff, "мceк",_form(1,3,2,2) },
    { "Ти-РТпреp-уст ", &_r.KRTPRI            , 0               , (sw)0xFFFFu      , 64           ,(w*)&_ind_Nom,  1             , 0xff, "мceк",_form(1,3,2,2) },
    { "'Ти-РТнепp    ", &_r_KRTNI             , 0               , (sw)0xFFFFu      , 64           ,(w*)&_ind_Nom,  0             , 0xff, "мceк",_form(1,3,2,2) },
    { "'Ти-РТнепp-AH ", &an_KRTNI             , 0               , (sw)0xFFFFu      , 64           ,(w*)&_ind_Nom,  0             , 0xff, "мceк",_form(1,3,2,2) },
    { "Ти-РТнепp-уст ", &_r.KRTNI             , 0               , (sw)0xFFFFu      , 64           ,(w*)&_ind_Nom,  16            , 0xff, "мceк",_form(1,3,2,2) },
    { "K-РТ-дин      ", &_r.KRTDI

====================================================================================================
далее
    bx = IDN - ZIDN ;
      if ( (sw)bx >= 0 )
        {
          if ( S.flg._.Fmax == 1 )  goto r ;
        }
      else
        {
          if ( S.flg._.Fmin == 1 )  goto r ;
        }
   ri:
   lax = KRTI ;

   if ( lax == 0 )
     {             // инициализация интегратора при Ки = 0 :
       OIRT = _r.RevU0 ;
       OIRT_drob = 0 ;
       goto r ;
     }

  { "U0-реверс     ", &_r.RevU0
    *=-=============================================================================================
    * далее
    *
    *  //-------------- 01.04.09 -------------------------------------

    // 3.3 мс - такт счёта , раз в пульс .
    // 65535  - основание интегратора и выхода РТ (дробная часть) , в конце происходит сдвиг на 16 разрядов влево .
    // 64     - основание уставки Ти (дробная часть) для возможности задать доли миллисекунды .
    lax = (lw)( (d)_Grad( 1 ) / (d)_Id_nom ( 0.01 ) *  3.3 * 65535. * 64. ) / lax ;
    lax &= 0x7ffffffful ;  //защита от "-" коэфф.

    //--------------------------------------------------
    cx = bx ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)bx >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Ki',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)bx ;     // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    // lax = (lw) bx * (lw) KRTI ;
    // if ( lax > 0x4000u ) lax = 0x4000u ;
    if ( (slw)lax >= ((slw)0x4000u << 16) )   lax = (lw)0x4000u << 16 ;  //оставшееся ограничение Шестакова

    if ( tst1 == 1 && (slw)lax >= ((slw)0x0f00u << 16) )   lax = (lw)0x0f00u << 16 ;  // ограничение при tst1==1

          cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)OIRT >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)OIRT <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)OIRT << 16 ;
     lax += (lw)(w)OIRT_drob ;   // DROB ISN'T SIGNED !

              Проверка переполнений.
    //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto v1 ;
    //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto v2 ;
    //--------------------------------------------------

               Проверка ограничений.
          if ( (slw)lax < ((slw)_r.RTMIN << 16) )
    {
        v2:       lax = (lw)_r.RTMIN << 16 ;
    }
          else if ( (slw)lax >= ((slw)_r.RTMAX << 16) )
    {
        v1:       lax = (lw)_r.RTMAX << 16 ;
    }

    OIRT = (slw)lax >> 16 ; // дробная часть уходит, целая записывается .
    OIRT_drob = lax ;       // запись дробной части .

    if ( tst1 == 1 )  goto ri_ok  ;
    if ( tst3 == 1 )  goto ri_ok1 ;

где
      "РТ-вых-макс   ", &_r.RTMAX             ,_Grad( 0.0 )     ,_Grad( 179.0 )    ,_Grad(1.0)    ,(w*)&_ind_Nom, _Grad( 1.0 )   , 0xff, "грд", _form(1,3,0,2) },
    { "РТ-вых-мин    ", &_r.RTMIN

===================================================================================================
    *далее значениее ORT перекладывается (не имеет переменной для отображения) вызывается в проограмме линеаризация
    *
    *
//------------------------------------
		Программа линеаризации
    void Linear (void)
    {
        register word  ax , bx , cx ;

        if ( ORT <= _Ugol_90 )  ax = ORT ;
        else                    ax = _Ugol_180 - ORT ;
        bx  = LIN [ ax >> 8 ] ;
        cx  = LIN [(ax >> 8) + 1 ] ;
        cx -= bx ;
        bx += (w)( (lw)cx * (lw)(ax & 0x00FFu) / 0x0100ul ) ;
        if ( ORT <= _Ugol_90 ) S.Alfa = bx;
        else                   S.Alfa = _Ugol_180 - bx ;
        return;

    }


    где ORT перекладывается в S.Alfa, а тот в свою очередь уже используется в сифу.
    { "L#    ", &S.Alfa

    *=================================================================================
    *
    *
    *
    *
    *
    *
    *
    *
    */


    public void InputSifu (){

    }

}
