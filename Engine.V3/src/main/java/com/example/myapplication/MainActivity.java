/*16.09.19 - начинаю пилить движок.
* 1 - вывести просто фон.
*
*
*
*
*
* */
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------------------------------------------
* зАПУСК СТОРОННЕГО ПРИЛОЖЕНИЯ НА АНДРОИД СИМУЛЯТОРЕ
* зАПУСТИТЬ avd-manager -  pfgecnbnm эмулятор- найти путь platform-tools - запустить окно W+R
* далле все как по примеру.
*
*Выполнить эмулятор (SDK Manager.exe- > Инструменты- > Управление AVD...- > Новый, затем Пуск)
Запустите консоль (Windows XP), запустите → введите cmd и перейдите в папку платформы каталога SDK.
Вставьте файл APK в папку "android-sdk\tools" или "platform-tools".
Затем введите следующую команду.

adb install [.apk path]

Пример:

adb install C:\Users\Name\MyProject\build\Jorgesys.apk
*Microsoft Windows [Version 6.1.7601]
(c) Корпорация Майкрософт (Microsoft Corp.), 2009. Все права защищены.
C:\Users\Шпуряка>cd C:\Aleksandr\platform-tools
C:\Aleksandr\platform-tools>adb devisec
adb: usage: unknown command devisec
C:\Aleksandr\platform-tools>adb devices
List of devices attached
emulator-5554   device
C:\Aleksandr\platform-tools>adb install "D:\Новая папка\Графика андроид\Schemati
c_2.2.1.apk"
Success
C:\Aleksandr\platform-tools>
------------------------------------------------------------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-------------------------------------------------------------------------------------------------------------------------------
ConstraintLayout — это новый вид layout, который вы можете использовать в ваших Android-приложениях.
Эта компоновка обладает обратной совместимостью вплоть до API Level 9 и является частью Support Library.
Цель ConstraintLayout — уменьшить количество иерархий layout, улучшить производительность layout,
а также заменить работу с RelativeLayouts. Она совместима с другими компоновками, так что они могут прекрасно
гармонировать друг с другом.
*-----------------------------------------------------------------------------------------------------------------
*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
* ---------------------------------------------------------------------------------------------------------------------
* Splash Screen (прим.: тут и далее — экран загрузки)
* Что рекомендует Google

Вы будете удивлены, узнав что сторонники Google используют Splash Screen. Это описано прямо вот тут, в
спецификации к Material Design.
Так было не всегда. Google был против Splash Screen, и даже назвал его анти-паттерном.
*Правильный Splash Screen

Я считаю, что Google не противоречит сам себе. Старый совет и новые рекомендации хорошо сочетаются.
(Тем не менее, все-таки не очень хорошая идея использовать экран загрузки который отнимает время пользователя.
 Пожалуйста, не делайте так)

Однако, Android приложениям требуется некоторое количество времени для запуска, особенно при холодном запуске.
Существует задержка которую вы не можете избежать. Вместо того чтобы показывать пустой экран, почему бы не
показать пользователю что-то хорошее? Именно за этот подход Google и выступает. Не стоит тратить время пользователя,
 но не показывайте ему пустой, ненастроенный раздел приложения, когда он запускает его впервые.

Если вы посмотрите на последние обновления Google приложений, вы увидите подобный способ использования экрана
 загрузки. Например, взгляните на приложение YouTube:
*
*Количество времени, которые вы тратите на просмотр Splash Screen, точно соответствует количеству времени,
 *  которое требуется приложению для запуска. При холодном запуске, это означает что Splash Screen будет виден дольше.
 *  А если приложение уже закэшировано, заставка исчезнет почти сразу.
*
* Реализация Splash Screen


Реализация Splash Screen правильным способом немного отличается от того что вы можете себе приставить.
Представление Splash Screen, который вы видите, должно быть готово немедленно, даже прежде чем вы можете раздуть
(прим.: inflate) файл макета в вашей Splash Activity (прим.: Activity — активность, деятельность).

Поэтому мы не будем использовать файл макета. Вместо этого мы укажем фон нашего Splash Screen в фоне темы своей Activity.
 Для этого, сначала необходимо создать XML drawable в res/drawable.   -background_splash.XML
*Здесь я задал цвет фона и изображение.

Дальше, вы должны установить этот drawable в качестве фона для темы вашего Splash Screen Activity.
Перейдите в файл styles.xml и добавьте новую тему для Splash Screen Activity:
 <style name="SplashTheme" parent="Theme.AppCompat.NoActionBar">
        <item name="android:windowBackground">@drawable/background_splash</item>
    </style>

В вашей новой SplashTheme установите в качестве фона ваш XML drawable. И установите эту тему в своей
Splash Screen Activity в вашем AndroidManifest.xml:

*
*
* Класс SplashActivity должен перенаправить вас в ваше основное Activity:
* Обратите внимание, что вы не настраивает вид для SplashActivity. Представление берется непосредственно из темы.
 * Когда вы задаете вид вашей Splash Screen Activity через тему, он доступен немедленно.

Если у вас есть файл макета для вашей Splash Activity, он будет показан только после того как
 ваше приложение будет полностью инициализировано, а это что очень поздно. Ведь мы хотим чтобы
 Splash Screen отображался только небольшой промежуток времени, до того как приложение будет инициализировано.
*
*
* Вооруженные этим знанием, заставьте ваш Splash Screen работать правильно. Не тратьте время пользователей попусту,
 * но дайте им то, на что им будет приятно смотреть пока они ждут.
 *
 * !!!!!Добавление цвета в colors.xml
 * <?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="gray">#444440</color>
</resources>
 *
 * --------------------------------------------------------------------------------------------------------------------
 *
 *
 * ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * --------------------------------------------------------------------------------------------------------------------
 * Создаем много экранное приложение
 *  p0211twoactivity
 *
 *   - указать имя этого Activity – в MainActivity - по отпусканию нажатия.
 *   - New -> Activity -> Empty Activity (Третий пункт по ходу должен появиться авитоматически.)
 *   - Activity «регистрируется» в системе с помощью манифест-файла - AndroidManifest.xml.
 * --------------------------------------------------------------------------------------------------------------------
 *
 *
 *
 * ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * ---------------------------------------------------------------------------------------------------------------------
 *Создаю БД.
 * создадим базу данных SQLite (внешнюю) Расширение dp/. В этом нам может помочь такой инструмент как Sqlitebrowser.
 * (создадим базу данных SQLite. В этом нам может помочь такой инструмент как Sqlitebrowser)
 *
 * После создания таблицы добавим в проект в Android Studio папку assets, а в папку assets -
  * только что созданную базу данных.
 * Создадим отдельный класс для рабты с БД.DatabaseHelper
 *
 * В главном активити создам базу данных для работы, а именно копируем с основной в рабочую
 *
 *
 * ---------------------------------------------------------------------------------------------------------------------
 *
 * /////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * --------------------------Производу различные запросы к БД------------------------------------------------
 * На rawQuery.
 *
 *
 *
 *
 * --------------------------------------------------------------------------------------------------------------------
 *
 * /////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * --------------------------Работа с курсором для БД.------------------------------------------------
 *http://developer.alexanderklimov.ru/android/sqlite/cursor.php
 * Android_ Cursor /Cursor
 * абота с курсором
Курсор - это набор строк в табличном виде
Для доступа курсора вы должны использовать метод moveToFirst(), так как курсор размещается перед первой строкой
Вы должны знать названия столбцов
Вы должны знать типы столбцов
Все методы доступа к массивам основываются на номере столбца, поэтому сначала нужно преобразовать название
столбца в номер столбца
Курсор является случайным (random cursor) - вы можете переходить вперед, назад и со строки на строку
Поскольку курсор является случайным, у него можно запрашивать количество строк (row count)
Класс Cursor содержит немало возможностей для навигации (но не ограничивается только ими):

moveToFirst() — перемещает курсор на первую строку в результате запроса;
moveToNext() — перемещает курсор на следующую строку;
moveToLast() - перемещает курсор на последнюю строку;
moveToPrevious() — перемещает курсор на предыдущую строку;
getCount() — возвращает количество строк в результирующем наборе данных;
getColumnIndexOrThrow() — возвращает индекс для столбца с указанным именем (выбрасывает исключение,
если столбец с таким именем не существует);
getColumnName() — возвращает имя столбца с указанным индексом;
getColumnNames() — возвращает массив строк, содержащий имена всех столбцов в объекте Cursor;
moveToPosition() — перемещает курсор на указанную строку;
getPosition() — возвращает текущую позицию курсора
Также Android предоставляет следующие методы:

isBeforeFirst()
isAfterLast() - полезный метод, сигнализирующий о достижении конца запроса. Используется в циклах
isClosed()

осле вызова метода первая строчка таблицы подсвечена. Именно данные этой строки и содержит сейчас курсор.
 Можно проверить следующим образом. Добавим новую кнопку в проект и напишем код:


public void onCursorClick(View v) {
	String query = "SELECT " + CatsDataBase._ID + ", "
			+ CatsDataBase.CATNAME + " FROM " + CatsDataBase.TABLE_NAME;
	Cursor catCursor = sqdb.rawQuery(query, null);
	catCursor.moveToFirst(); // переходим на первую строку
	// извлекаем данные из курсора
	int item_id = catCursor
			.getInt(catCursor.getColumnIndex(CatsDataBase._ID));
	String item_content = catCursor.getString(catCursor
			.getColumnIndex(CatsDataBase.CATNAME));
	catCursor.close();

	txtData.setText("id: " + item_id + " Имя кота: " + item_content);
}На первой строке содержатся данные 1, Мурзик. Мы не знаем, как хранятся данные в курсоре, но нам это и не нужно.
С помощью метода getColumnIndex() с указанием имени колонки мы можем извлечь данные, которые хранятся в них.
 *
 *Теперь вызовем метод moveToNext() (перейти к следующей строке). Таблица будет выглядеть уже так:
 *
 *
 * public void onCursorClick(View v) {
	String query = "SELECT " + CatsDataBase._ID + ", "
			+ CatsDataBase.CATNAME + " FROM " + CatsDataBase.TABLE_NAME;
	Cursor catCursor = sqdb.rawQuery(query, null);
	catCursor.moveToFirst();
	catCursor.moveToNext(); // переходим к следующей записи
	int item_id = catCursor
			.getInt(catCursor.getColumnIndex(CatsDataBase._ID));
	String item_content = catCursor.getString(catCursor
			.getColumnIndex(CatsDataBase.CATNAME));


	catCursor.close();

	txtData.setText("id: " + item_id + " Имя кота: " + item_content);
}
Если вызвать метод moveToNext() ещё раз, то переместимся на третью позицию. А теперь представьте ситуацию,
что у нас в базе более ста котов, и чтобы узнать имя 85-го кота, нам придётся 85 раз вызывать метод. Не удобно.
К счастью, есть метод moveToPosition() (перейти в позицию), в котором сразу можно указать нужную строку (отсчет идет от 0):


...
catCursor.moveToFirst();
catCursor.moveToPosition(2); // прыгаем на третью запись
 * --------------------------------------------------------------------------------------------------------------------
 *
 * /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * -------------------------------------------------------------------------------------------------------------------
 *                            Глобальная переменная и БД.
 * Глобальная переменная - сохранение значения в течение жизненного цикла приложения независимо от того,
 * какая активность работает.
    1-й вариант ============================================================================================
        расширить базовый класс android.app.Application и добавить переменные-члены следующим образом:

    public class MyApplication extends Application {
        private String someVariable;
        public String getSomeVariable() {
            return someVariable;
        }
        public void setSomeVariable(String someVariable) {
            this.someVariable = someVariable;
        }
     }
 *В манифесте Android вы должны объявить класс, реализующий
 * android.app.Application(добавьте атрибут android:name=".MyApplication" к существующему тегу приложения):
 *  <application
            android:name=".MyApplication"
            android:icon="@drawable/icon"
            android:label="@string/app_name">

Затем в ваших действиях вы можете получить и установить переменную следующим образом:
    // set
    ((MyApplication) this.getApplication()).setSomeVariable("foo");
    // get
    String s = ((MyApplication) this.getApplication()).getSomeVariable();

еще пример---=================================================================================================

Глобальные переменные зло, если только с ними неправильно обращаться. По самой сути явления всегда есть переменные,
которые должны быть глобальными - скажем хэндлер к БД (или если угодно хэндлер к DAO) - он по сути своей глобален -
нравится это кому то или нет.
Идеальным местом для хранения таких глобальных вещей является объект Application, который является естественным
 синглтоном для Android аппликации.

Надо декларировать в манифесте кастомный Application класс и "положить" туда свои глобальные переменные туда
(обложив сеттерами/геттерами). Application практически везде доступен через Activity.getApplication()

    public class MyApplication extends Application {
        private MyPreciousClass myPreciousObject;

          public MyPreciousClass getMyPreciousObject() {
            return this.myPreciousObject;
          }
    }

//где в коде
MyApplication myApp=(MyApplication)this.getApplication();
myPreciousObject=myApp.getMyPreciousObject();
====================================================================================================



 *
 * 2- й варант - использовать Singleton Pattern следующим образом:
 * 2--й=================================================================================================
 *                                  Singleton Pattern
 *
 * Пример выполнения.
 * Одиночка — это порождающий паттерн, который гарантирует существование только одного объекта
  * определённого класса, а также позволяет достучаться до этого объекта из любого места программы.
  *
 *Применимость: Многие программисты считают Одиночку антипаттерном, поэтому его всё реже и реже
 * можно встретить в Java-коде.
Тем не менее, Одиночке нашлось применение в стандартных библиотеках Java:
    java.lang.Runtime#getRuntime()
    java.awt.Desktop#getDesktop()
    java.lang.System#getSecurityManager()
Признаки применения паттерна: Одиночку можно определить по статическому создающему методу,
который возвращает один и тот же объект.
 *
 *Наивный Одиночка (один поток)
    Топорно реализовать Одиночку очень просто — достаточно скрыть конструктор и предоставить
    статический создающий метод.


Singleton.java: Одиночка
    package refactoring_guru.singleton.example.non_thread_safe;

public final class Singleton {
    private static Singleton instance;
    public String value;

    private Singleton(String value) {
        // Этот код эмулирует медленную инициализацию.
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        this.value = value;
    }

    public static Singleton getInstance(String value) {
        if (instance == null) {
            instance = new Singleton(value);
        }
        return instance;
    }
}
 *
 *DemoSingleThread.java: Клиентский код
package refactoring_guru.singleton.example.non_thread_safe;

public class DemoSingleThread {
    public static void main(String[] args) {
        System.out.println("If you see the same value, then singleton was reused (yay!)" + "\n" +
                "If you see different values, then 2 singletons were created (booo!!)" + "\n\n" +
                "RESULT:" + "\n");
        Singleton singleton = Singleton.getInstance("FOO");
        Singleton anotherSingleton = Singleton.getInstance("BAR");
        System.out.println(singleton.value);
        System.out.println(anotherSingleton.value);
    }
}
 *
 *OutputDemoSingleThread.txt: Результаты выполнения
    If you see the same value, then singleton was reused (yay!)
    If you see different values, then 2 singletons were created (booo!!)
    RESULT:
    FOO
    FOO
 *=====================================================================================================
еще один вариант исользования Singleton вариант
 * Особенность реализации Singleton в Java за три шага

Поведение Одиночки на Java невозможно реализовать с помощью обычного конструктора, потому что конструктор
всегда возвращает новый объект. Поэтому все реализации Singleton’a сводятся к тому, чтобы скрыть конструктор и
 создать публичный статический метод, который будет управлять существованием объекта-одиночки и «уничтожать»
  всех вновь-появляющихся объектов. В случае вызова Singleton’a он должен либо создать новый объект
  (если его еще нет в программе), либо вернуть уже созданный. Для этого:

#1. – Нужно добавить в класс приватное статическое поле, содержащее одиночный объект:

public class LazyInitializedSingleton {
	private static LazyInitializedSingleton instance; //#1
}

#2. – Сделать конструктор класса (конструктор по-умолчанию) приватным (чтобы доступ к нему был закрыть
за пределами класса, тогда он не сможет возвращать новые объекты):

public class LazyInitializedSingleton {
	private static LazyInitializedSingleton instance;
private LazyInitializedSingleton(){} // #2
}

#3. – Объявить статический создающий метод, который будет использоваться для получения одиночки:

public class LazyInitializedSingleton {
    private static LazyInitializedSingleton instance;
        private LazyInitializedSingleton(){}
        public static LazyInitializedSingleton getInstance(){ // #3
        if(instance == null){		//если объект еще не создан
            instance = new LazyInitializedSingleton();	//создать новый объект
        }
        return instance;		// вернуть ранее созданный объект
    }
}

 * =========================================================================================================
 *еще пример  Singleton Pattern
 * Вы можете использовать Singleton Pattern следующим образом:

package com.ramps;

public class MyProperties {
private static MyProperties mInstance= null;   // статич приватный метод

public int someValueIWantToKeep;

protected MyProperties(){}      // конструктор метода

public static synchronized MyProperties getInstance() {   // статический метод для получения одиночки
        if(null == mInstance){
            mInstance = new MyProperties();
        }
        return mInstance;
    }
}
 *  В вашем приложении вы можете получить доступ к своему синглтону таким образом:
        MyProperties.getInstance().someValueIWantToKeep
  ===============================================================================================================
 *
 *Всегда лучше хранить значения, которые вы хотите использовать несколько раз одним из следующих способов: -

Общие настройки
Одиночные классы
записать его в файл
База данных SQLite
Сохранить на веб-сервере
================================================================================================================

Если вам нужна глобальная переменная, которая разделяется между несколькими действиями и сохраняется их изменения
 в жизненном цикле, но в остальном она не сохраняется и не сможет перезапустить перезапуск приложения, метод,
  предложенный в первом ответе (расширение Application и его размещение там) нормально.
Если вам нужна постоянная глобальная настройка, которая также должна выдержать перезапуск приложения, вам
следует использовать один из других предложенных методов. SharedPreferences, вероятно, самый простой в использовании.
=================================================================================================================


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
=================================================================================================================
------------------------------ Ичпользоывание onResume()
onResume() метода onResume() сама по себе безвредна. Но вызов ему супер метода super.onResume();
 позволит системе думать, что это еще одно событие возобновления. Это приведет к ненужному использованию
 ресурсов для обновления просмотров и подобных внутренних работ. Поэтому вы должны избегать явных вызовов
 методов обратного вызова жизненного цикла при любых обстоятельствах.

 Вот мое окончательное кодирование, благодаря Ахамаду за отличное руководство. Я никогда не вызываю onResume().
  В разных местах я вызываю myOnResume(). Код part1() - это все расширенные вычисления.
  Код part2() - это все операции вывода.

@Override
    public void onResume()
    {   super.onResume();//
        myOnResume();
    }// end: onResume.

    void myOnResume()
    {   new Thread(new Runnable()
        {   public void run()                   //run #1
            {   part1();                        // do all the calculations in background.
                runOnUiThread(new Runnable()
                {   public void run()           //run #2
                    {   part2();                // do the display in the UI thread.
                    }                           //end of run#2
                });                             //end of runOnUiThread
            }                                   //end of run#1
        }).start();
    }                                           //end: myOnResume()

 *-----------------------------------------------------------------------------------------------------------------
 *
 *
 *
 * //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *===================================================================================================================
 * -----------------использование файлов ресурсов-----------------------------------------------------------
 * http://developer.alexanderklimov.ru/android/theory/resources.php
 * Android_ Ресурсы
 *
 *
 * В Android принято держать некоторые объекты - изображения, строковые константы, цвета, анимацию, стили
 * и т.п. за пределами исходного кода. Система поддерживает хранение ресурсов в отдельных файлах.
 * Ресурсы легче поддерживать, обновлять, редактировать.
 *
 * Каждое приложение на Android содержит каталог для ресурсов res и каталог для активов assets.
 * Реальное различие между ресурсами и активами заключается в следующем:

    ---   информация в каталоге ресурсов будет доступна в приложении через класс R, который автоматически генерируется средой
 разработки. То есть хранение файлов и данных в ресурсах (в каталоге res) делает
  их легкодоступными для использования в коде программы;


  -     для чтения информации, помещенной в каталог активов assets (необработанный формат файла), необходимо
  использовать AssetManager для чтения файла как потока байтов.

 *Ресурсы в Android являются декларативными. В основном ресурсы хранятся в виде XML-файлов в каталоге
  *  res с подкаталогами values, drawable-ldpi, drawable-mdpi, drawable-hdpi, layout, но также бывают и другие типы ресурсов.

Для удобства система создает идентификаторы ресурсов и использует их в файле R.java (класс R,
 который содержит ссылки на все ресурсы проекта), что позволяет ссылаться на ресурсы внутри кода программы.
 *
 * Самыми распространёнными ресурсами являются, пожалуй, строки (string), цвета (color) и графические рисунки (bitmap).
 * В приложении не рекомендуется применять жёстко написанные строки кода - вместо них следует использовать
  * соответствующие идентификаторы, что позволяет изменять текст строкового ресурса, не изменяя исходного кода.
 *
 * Начинающие программисты не всегда до конца правильно понимают процесс создания ресурсов.
 * В Android используются два подхода - первый подход заключается в том, что ресурсы задаются
 * в файле, при этом имя файла значения не имеет. Второй подход - ресурс задаётся в виде самого файла,
  * и тогда имя файла уже имеет значение (при этом нужно учитывать определённые нюансы).

Общая структура каталогов, содержащих ресурсы выглядит следующим образом:

/res/values/strings.xml
           /colors.xml
		   /dimens.xml
		   /attrs.xml
		   /styles.xml
	/drawable/ *.png
             / *.jpg
             / *.gif
             / *.9.png
    /anim/ *.xml
    /layout/ *.xml
    /raw/ *.*
    /xml/ *.xml
/assets/ * .* /
        Только в assets может располагаться любой набор подкаталогов разной вложенности. Файлы,
        находящиеся в любом другом каталоге, размещаются именно на уровне этого каталога и не глубже.
 *
 *Идентификаторы
Этот тип ресурсов формируется, как правило, автоматически, и программисты даже не обращают на него внимания.
 в виде @+id/editText (часто это происходит автоматически). Знак плюса обозначает, что если идентификатора не
 существует, то его нужно создать в классе R. В программе вы можете обращаться к элементу R.id.editText.
 *
 * Но можно заранее создать ресурс типа item для задания id, не связанного ни с каким конкретным ресурсом:

<resources>
    <item type="id" name="text"/>
</resources>
Здесь type описывает тип ресурса, в данном случае id. Когда id будет установлен, будет работать и следующее определение View:


<TextView android:id="@id/textView">
    </TextView>
Обычно идентификаторы размещают в отдельном файле res/values/ids.xml.
-----------------------------------------------------------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
---------------------------------------------------------------------------------------------------------------------
------------------Создание классов с методами и свойствами------------------------------------------
 * Передача праметров методу в класс. Обработка и возврат строкового ресурса дя вывода в диалоге.
 *
 *----------------------------------------------------------------------------------------------------------------------
 *
 *
 *
 * ////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * --------------------------------------------------------------------------------------------------------
 * ---исползование диалога------------------------------------------------------
 *Настраиваемые  CustomDialogFragment. В него передаю зхаголовок и сообщение + настраиваемые кнопки.
 * В зависимоти о логики класса передабю сообщение.
 * есурс - (DialogFragment) https://developer.android.com/reference/android/app/DialogFragment.html
 * ---------------------------------------------------------------------------------------------------
 *
 //////////////////////////////////////////////////////////////////////////////////////////////////
 *--------------------------------------------------------------------------------------------------
 * --------------Поочередный вывод диалога.
 *с помощью массива
 *.-------------------------------------------------------------------------------------------------
 *
 *
 //////////////////////////////////////////////////////////////////////////////////////////////
 --------------------------Мигание блка в отдельном пооке -------------------------------------
 Потоки позволяют выполнять несколько задач одновременно, не мешая друг другу, что даёт возможность
  эффективно использовать системные ресурсы. Потоки используются в тех случаях, когда одно долгоиграющее
  действие не должно мешать другим действиям. Например, у нас есть музыкальный проигрыватель с
  кнопками воспроизведения и паузы. Если вы нажимаете кнопку воспроизведения и у вас запускается
  музыкальный файл в отдельном потоке, то вы не можете нажать на кнопку паузы, пока файл не
  воспроизведётся полностью. С помощью потоков вы можете обойти данное ограничение.

Использование фоновых потоков
Чтобы быть уверенным, что ваше приложение не теряет отзывчивости, хорошим решением станет
перемещение всех медленных, трудоёмких операций из главного потока приложения в дочерний.

Все компоненты приложения в Android, включая активности, сервисы и приёмники широковещательных
намерений, начинают работу в главном потоке приложения. В результате трудоёмкие операции в любом
из этих компонентов блокируют все остальные части приложения, включая сервисы и активности на переднем плане.
Применение фоновых потоков — необходимое условие, если вы хотите избежать появления диалогового
 окна для принудительного закрытия приложения. Когда активность в Android на протяжении 5 секунд
  не отвечает на события пользовательского ввода (например, нажатие кнопки) или приёмник
  широковещательных намерений не завершает работу обработчика onReceive() в течение 10 секунд,
   считается, что приложение зависло. Подобные ситуации следует избегать любой ценой.
   Используйте фоновые потоки для всех трудоёмких операций, включая работу с файлами,
   сетевые запросы, транзакции в базах данных и сложные вычисления.

Android предоставляет несколько механизмов перемещения функциональности в фоновый режим.

Activity.runOnUiThread(Runnable)
View.post(Runnable)
View.postDelayed(Runnable, long)
Handlers
AsyncTask
Класс AsyncTask позволяет определить операции, которые будут выполняться в фоне, вы также будете
 иметь доступ к обработчику событий, что позволит отслеживать прогресс выполнения задач и выводить
  результаты в контексте главного графического потока. Подробнее об этом классе в отдельной статье.

Хотя использование AsyncTask — хорошее решение, случается, что для работы в фоновом режиме
 приходится создавать собственные потоки и управлять ими.

В Java есть стандартный класс Thread, который вы можете использовать следующим образом:


new Thread(new Runnable() {
    public void run() {
      //do time consuming operations
      });
    }
}).start();
 *Данный способ подходит только для операций, связанных с временем. Но вы не сможете обновлять
  *  графический интерфейс программы.

Если вам нужно обновлять интерфейс программы, то нужно использовать AsyncTask, о котором говорилось
 выше, или вы можете реализовать ваш собственный класс, наследованный от Thread, используя объект
 Handler из пакета android.os для синхронизации с потоком GUI перед обновлением пользовательского интерфейса.

Вы можете создавать дочерние потоки и управлять ими с помощью класса Handler, а также классов,
 доступных в пространстве имён java.lang.Thread. Ниже показан простой каркас для переноса операций в дочерний поток.


// Этот метод вызывается из главного потока GUI.
private void mainProcessing() {
    // Здесь трудоемкие задачи переносятся в дочерний поток.
    Thread thread = new Thread(null, doBackgroundThreadProcessing,
            "Background");
    thread.start();
}
// Объект Runnable, который запускает метод для выполнения задач
// в фоновом режиме.
private Runnable doBackgroundThreadProcessing = new Runnable() {
    public void run() {
        backgroundThreadProcessing();
    }
};
// Метод, который выполняет какие-то действия в фоновом режиме.
private void backgroundThreadProcessing() {
    [ ... Трудоемкие операции ... ]
}
 *
 *Основной поток также называют UI-потоком. Имено в главном потоке можно обновить текст у текстовой
  *  метки. В создаваемых нами потоках это делать нельзя. Если вы уберёте комментарии с последнего
   *  примера и запустите проект, то получите сообщение об ошибке.

Нужен некий посредник между создаваемыми потоками и основным UI-потоком. В роли такого посредника
служит класс Handler (полное название класса android.os.Handler, не перепутайте).
Вам нужно создать экземпляр класса и указать код, который нужно выполнить.
 *
 *
 * Запуск потока
Предположим, мы разрабатываем собственный проигрыватель. У нас есть кнопка Play,
 которая вызывает метод play() для воспроизведения музыки:


Button playButton = (Button) findViewById(R.id.play);
playButton.setOnClickListener(new View.OnClickListener()) {
    public void onClick(View v) {
	    play(); // вызываем воспроизведение
    }
}
Теперь запустим метод в другом потоке. Сначала создаётся новый поток. Далее описывается объект
Runnable в конструкторе потока. А внутри созданного потока вызываем наш метод play(). И, наконец, запускаем поток.


Thread myThread = new Thread( // создаём новый поток
    new Runnable() { // описываем объект Runnable в конструкторе
	    public void run() {
		    play(); // вызываем метод воспроизведения
	    }
    }
);
Усыпить поток
Иногда требуется временно приостановить поток ("усыпить"):


// засыпаем на 2 секунды (в миллисекундах)
myThread.sleep(2000);
Приоритет потоков
Для установки приоритета процесса используется метод setPriority(), который вызывается до запуска
 потока. Значение приоритета может варьироваться от Thread.MIN_PRIORITY (1) до Thread.MAX_PRIORITY (10):


myThread.setPriority(10);
myThread.start();
Отмена выполнения потока
У потока есть метод stop(), но использовать его не рекомендуется, поскольку он оставляет
приложение в неопределённом состоянии. Обычно используют такой подход:


if (myThread != null) {
    Thread dummy = myThread;
	myThread = null;
	dummy.interrupt();
}
Существует и другой способ, когда все запускаемые потоки объявляются демонами. В этом случае
все запущенные потоки будут автоматически завершены при завершении основного потока приложения:


myThread.setDaemon(true);
myThread.start();
 *
 *!!!!!!!!!!!!!!!!!!!!взято по примеру https://www.tutorialspoint.com/how-to-make-the-textview-blinking-in-android
 * How to make the textview blinking in android?
 *
 *
 * public class MainActivity extends AppCompatActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);
      blinkTextView();
   }
   private void blinkTextView() {
      final Handler handler = new Handler();
      new Thread(new Runnable() {
         @Override
         public void run() {
            int timeToBlink = 1000;
            try{Thread.sleep(timeToBlink);}catch (Exception e) {}
            handler.post(new Runnable() {
               @Override
               public void run() {
                  TextView txt = findViewById(R.id.text);
                  if(txt.getVisibility() = = View.VISIBLE){
                     txt.setVisibility(View.INVISIBLE);
                  } else {
                     txt.setVisibility(View.VISIBLE);
                  }
                  blinkTextView();
               }
            });
         }
      }).start();
   }
}
 *
 *--------------------------------------------------------------------------------------------------
 *
 *
 *
 /////////////////////////////////////////////////////////////////////////
 *--------------Разница Handler, AsyncTask , Thread---------------------------------------------
 * Я немного запутался в различиях между Handlers, AsyncTask и Threads в Android. Я прочитал немало блогов
  * и вопросов здесь, в Кару.

Handler являются фоновыми потоками, которые предоставляют вам возможность общаться с пользовательским интерфейсом.
 Например, обновление индикатора выполнения должно выполняться через Handler. Используя обработчики,
  вы получаете преимущество MessagingQueues, так что если вы хотите планировать сообщения или обновлять
   несколько элементов пользовательского интерфейса или выполнять повторяющиеся задачи.

AsyncTask похожи, на самом деле они используют Handler, но не работают в потоке пользовательского
интерфейса, так что это хорошо для извлечения данных, например, для извлечения веб-сервисов.
Позже вы можете взаимодействовать с пользовательским интерфейсом.

Однако Thread не может взаимодействовать с пользовательским интерфейсом, обеспечивает более
"базовую" многопоточность, и вы упускаете все абстракции AsyncTask.

Тем не менее, я хотел бы, чтобы соединение с сокетом работало. Должно ли это быть выполнено
в обработчике или потоке, или даже в AsyncTask? Взаимодействие с интерфейсом вообще не нужно.
 Имеет ли это значение с точки зрения производительности, которую я использую?
 *
 *Класс Handler может использоваться для регистрации в потоке и обеспечивает простой канал для отправки данных в этот поток.

Класс AsyncTask инкапсулирует создание фонового процесса и синхронизацию с основным потоком. Он также поддерживает отчеты о ходе выполнения задач.

А Thread - это основной элемент многопоточности, который разработчик может использовать со следующим недостатком:
 *
 *-------------------------------------------------------------------------------------------------
 *
  //------------------------------------------------------------------------------------------------
 //--===============================================================================================
  Добавка второго диалога, через case и передачу дополнительного аргумента
    public static CustomDialogFragment newInstance(int title, String phone,int id)
    ................
      switch (id) {...........
 //-------------------------------------------------------------------------------------------------

 *
 * //--------------------------------------------------------------------------------------------
 * Добавка svg in splash_activity
 * 1.  использую  AnimatedVectorDrawable
 * 2. использую анимационные атрибуты в VectorDrawable
 * 3. прописываю файл vectordrawable.xml - сам рисунгк с координатами
 * 4.  определяем AnimatedVectorDrawable - имена частей, путей  ицели android:animation - здесь симфайлы анимации
 * использую в этих файлах objectAnimator.
 * 5. в коде использую
 * androidView =(ImageView)findViewById(R.id.android);
  *
  * ((Animatable) androidView.getDrawable()).start();
 *
 *6. в layout ссылаемся на  анимации
 *  <ImageView
            android:id="@+id/android"
            android:layout_width="328dp"
            android:layout_height="328dp"
            android:contentDescription="@null"
            android:padding="8dp"
            android:scaleType="fitCenter"
            app:srcCompat="@drawable/anime_droid"
            android:onClick="showDialog"
            android:layout_centerVertical="true"
            android:layout_centerHorizontal="true" />

            , окторая в свою очередь ссылается на вектор

  7. отключил в стилях
    <!--<item name="android:windowBackground">@drawable/background_splash</item>  - Выводит иконку в стиле мне не надо-->
            чтоб не выводиьлась иконка

//----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
добавляеи меню -      МЕНЮ

Для определения пунктов меню всех типов в Android используется стандартный формат XML. Вместо того
 чтобы создавать меню в коде своей операции, определять меню и все его пункты следует в ресурсе меню
  формата XML. После этого ресурс меню можно будет загружать как объект Menu в свои операции или фрагменты.

 *Использовать ресурсы меню рекомендуется по нескольким причинам:
    - в XML проще визуализировать структуру меню;
    - это позволяет отделить контент для меню от кода, определяющего работу приложения;
    - это позволяет создавать альтернативные варианты меню для разных версий платформы, размеров
     экрана и других конфигураций путем использования структуры ресурсов приложения.

    Чтобы определить меню, создайте файл XML в папке res/menu/ вашего проекта и постройте меню со следующими элементами:
 *
 *<menu>
    Определяет класс Menu, который является контейнером для пунктов меню. Элемент <menu> должен быть
     корневым узлом файла, в котором может находиться один или несколько элементов <item> и <group>.
  <item>
    Создает класс MenuItem, который представляет один пункт меню. Этот элемент может содержать
     вложенный элемент <menu> для создания вложенных меню.
  <group>
     Необязательный, невидимый контейнер для элементов &lt;item&gt;. Он позволяет разделять пункты
     меню на категории и назначать им одинаковые свойства, такие как активное состояние и видимость.
      Подробные сведения изложены в разделе Создание групп меню.
 *
 *
 * Вот пример меню с именем game_menu.xml:

<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/new_game"
          android:icon="@drawable/ic_new_game"
          android:title="@string/new_game"
          android:showAsAction="ifRoom"/>
    <item android:id="@+id/help"
          android:icon="@drawable/ic_help"
          android:title="@string/help" />
</menu>

Элемент <item> поддерживает несколько атрибутов, с помощью которых можно определить внешний вид и поведение пункта меню. Пункты приведенного выше меню имеют следующие атрибуты:

android:id
Идентификатор ресурса, который является уникальным для этого пункта, что позволяет приложению распознавать пункт, когда его выбирает пользователь.
android:icon
Ссылка на графический элемент, который будет использоваться в качестве значка пункта меню.
android:title
Ссылка на строку, которая будет использоваться в качестве названия пункта меню.
android:showAsAction
Указывает, когда и как этот пункт должен отображаться в строке действий.
 *
 * то самые важные атрибуты, которые следует использовать, но есть также множество других атрибутов.
  * Сведения обо всех поддерживаемых атрибутах см. в документе Ресурс меню.

К пункту любого меню (кроме вложенного меню) можно прикрепить вложенное меню, добавив элемент
&lt;menu&gt; в качестве дочернего элемента &lt;item&gt;. Вложенные меню полезны, когда в приложении
 имеется множество функций, которые можно разделить на категории подобно строке меню приложения
 для ПК ("Файл", "Правка", "Вид" и т. д.). Например:

<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/file"
          android:title="@string/file" >
        <!-- "file" submenu -->
        <menu>
            <item android:id="@+id/create_new"
                  android:title="@string/create_new" />
            <item android:id="@+id/open"
                  android:title="@string/open" />
        </menu>
    </item>
</menu>

Для использования меню в операции необходимо загрузить ресурс меню (преобразовать ресурс XML в
программируемый объект) с помощью метода MenuInflater.inflate(). В приведенных далее разделах
 рассказывается, как загружать меню каждого типа.
 *
 *1. Теперь создайте новую папку menu в папке res (правый щелчок мыши на папке res,
 * | New | Directory). Далее создайте в созданной папке файл menu_main.xml - имя указывает,
 * что меню относится к основной активности MainActivity (правый щелчок мыши на папке menu
 * | New | Menu Resource File). Если вы будете создавать приложение с несколькими экранами,
 * то у каждой активности будет отдельное меню со своими настройками. Пока откроем файл menu_main.xml
  * и добавим в полученный шаблон свой код:
 *
 * <menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto"
      xmlns:tools="http://schemas.android.com/tools"
      tools:context=".MainActivity">
    <item
        android:id="@+id/action_settings"
        android:orderInCategory="100"
        android:title="@string/action_settings"
        app:showAsAction="never"/>
</menu>
 *  + строковый ресурс  <string name="action_settings">Settings</string>
 *
 *  !!!!!!!Параметр orderInCategory позволяет задать свой порядок вывода пунктов меню.
  *  Предположим вы создали пять пунктов меню, но пока не определились с порядком их вывода на экране.
   *  Чтобы не перемещать постоянно целые блоки кода для пунктов меню в нужном порядке,
    *  можно воспользоваться данным параметром.
    *
    *  И, наконец, важный атрибут app:showAsAction определяет поведение меню в ActionBar.
     *  Значение never означает, что элемент меню не должен выводиться в заголовке, а только
     *  в всплывающем меню, т.е. находиться за тремя точками. Если вы установите значение always,
      *  то пункт Settings сразу появится в заголовке вашего приложения. Также доступны значения
       *  ifRooms, withText и collapseActionView. Попробуйте самостоятельно. Например,
        *  ifRoom выводит пункт меню, если позволяет место. Если пунктов будет много, то они
         *  будут только мешаться. Как правило, в таком варианте выводят очень короткое слово
          *  или значок для частых операций, чтобы избежать лишнего щелчка на три точки.

Обратите внимание на атрибут app:showAsAction, который относится к пространству имён
 xmlns:app="http://schemas.android.com/apk/res-auto". Было время, когда такого пространства
  имён не существовало и в проектах использовался атрибут android:showAsAction из стандартного
   пространства имён. Если студия будет ругаться на ошибку, то отредактируйте код.
 *
 *
 *
 *
 *
 *2. Добавим новый метод onCreateOptionsMenu(). Именно данный метод отвечает за появление меню у
 * активности. Сразу после метода onCreate() начинайте вводить первые символы метода и дальше
  * студия сама покажет список подходящих методов.
 *
 *
 *Создание меню параметров

Рисунок 1. Меню параметров в браузере на Android 2.3.

В меню параметров следует размещать действия и другие варианты выбора, которые имеют отношение к
контексту текущей операции, например: "Поиск", "Составить сообщение эл. почты" и "Настройки".
 *
 *
 * Чтобы указать меню параметров для операции, переопределите onCreateOptionsMenu() (фрагменты
  * предоставляют собственный обратный вызов onCreateOptionsMenu()). В этом методе можно загрузить
  * собственный ресурс меню (определенный в XML) в класс Menu, имеющийся в обратном вызове. Например:
 *
 * @Override
public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.game_menu, menu);
    return true;
}

Пункты меню также можно добавлять с помощью add(), а получать их с помощью findItem() для пересмотра
их свойств с помощью API-интерфейсов MenuItem.

Если ваше приложение предназначено для версии Android 2.3.x или более ранней, система вызывает
метод onCreateOptionsMenu() для создания меню параметров, когда пользователь открывает это меню
впервые. Если приложение предназначено для версии Android 3.0 и или более поздней, система вызывает
методonCreateOptionsMenu() при запуске операции, чтобы отобразить пункты в строке действий.
 *
 *
 *
 * 3. Добавим обработку меню
 *
 * Обработка нажатий
Когда пользователь выбирает пункт меню параметров (в том числе пункты действий из строки действий),
система вызывает метод onOptionsItemSelected() вашей операции. Этот метод передает выбранный класс
MenuItem. Идентифицировать пункт меню можно, вызвав метод getItemId(), который возвращает уникальный
 идентификатор пункта меню (определенный атрибутом android:id из ресурса меню или целым числом,
 переданным методу add()). Этот идентификатор можно сопоставить с известными пунктами меню, чтобы
 выполнить соответствующее действие. Например:


@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle item selection
    switch (item.getItemId()) {
        case R.id.new_game:
            newGame();
            return true;
        case R.id.help:
            showHelp();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}

Когда пункт меню успешно обработан, возвращается true. Если пункт меню не обрабатывается,
следует вызвать реализацию суперкласса onOptionsItemSelected() (реализация по умолчанию возвращает
 значение false).

Если в вашей операции имеются фрагменты, система сначала вызовет метод onOptionsItemSelected()
для операции, а затем будет вызывать этот метод для каждого фрагмента (в том порядке, в котором
 они были добавлены), пока он не возвратит значениеtrue или не закончатся фрагменты.
 *




 ////////////////////////////////////////////////////////////////////////////////////////
https://o7planning.org/ru/10527/android-networking-tutorial
HttpURLConnection    --      чтобы работать с сетью.
...........................................................................................

Это официальный API Android, он был включен с версии Android 2.3, до этого Android использовал Apache HttpClient чтобы работать с сетью.

В Android сетевое программирование включает запросы на сервер и извлечение возвращенных данных. В принципе у вас есть 2 API чтобы работать с сетью:
-----------------------------------------------------------------
Для работы с сетью, требуется некоторые разрешения приложению:
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
----------------------------------------------------------
android.permission.INTERNET:
Добавьте это permission (разрешение), позвольте вашему приложению иметь возможность соединения сети.
android.permission.ACCESS_NETWORK_STATE:
Разрешите вашему приложению проверять статус соединения сети телефона.

------------------------------------------------------------------------------------------------------
Следующий код проверяет соединен ли к сети телефон пользователя или нет, метод возвращает  true если есть соединение, и false в обратном случае.
private boolean checkInternetConnection() {

     ConnectivityManager connManager =
             (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE);


     NetworkInfo networkInfo = connManager.getActiveNetworkInfo();

     if (networkInfo == null) {
         Toast.makeText(this, "No default network is currently active", Toast.LENGTH_LONG).show();
         return false;
     }

     if (!networkInfo.isConnected()) {
         Toast.makeText(this, "Network is not connected", Toast.LENGTH_LONG).show();
         return false;
     }

     if (!networkInfo.isAvailable()) {
         Toast.makeText(this, "Network not available", Toast.LENGTH_LONG).show();
         return false;
     }
     Toast.makeText(this, "Network OK", Toast.LENGTH_LONG).show();
     return true;
 }
--------------------------------------------------------------------------------------------------------
NetworkOnMainThreadException

По умолчанию, когда вы работаете с сетью (network) в Android, вам нужно создать новый thread чтобы отправлять и получать данные.
 Если вы работаете на главном  thread вы получите ошибку  android.os.NetworkOnMainThreadException, это регулирование по умолчанию
  у Android. Но вы можете заместить это регулирование, чтобы работать с сетью на главном  thread.
StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
StrictMode.setThreadPolicy(policy);


 AsyncTask<Params, Progress, Result>

 Рекомендуем вам создать класс расширенный из  AsyncTask<Params, Progress, Result>, этот класс не является  Thread-ом,
  он расширен из  Object, но при выполнении задания (Вызов методом  AsyncTask.execute(params)), он создает новый Thread
  чтобы сделать вызов методом  doInBackground(params). После того, как thread завершает вызывается метод  onPostExecute(result).



---------------------------------------------------------------------------------------------------------------------------



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Передача передать экземпляр Activity в конструктор  класса non-activity.

Метод getApplication() находится в классе Activity , поэтому всякий раз, когда вы хотите getApplication() в классе non activity,
 вам нужно передать экземпляр Activity в конструктор этого класса non-activity.

Предположим, что тест – это мой класс неактивности:

 Test test = new Test(this);
В этом классе я создал один конструктор:

  public Class Test { public Activity activity; public Test (Activity act) { this.activity = act; // Now here you can get getApplication() } }

------------------------------------------------------------------------------------------------------------------------------

FileWriter
Convenience class for writing character files. The constructors of this class assume that the default character encoding
and the default byte-buffer size are acceptable. To specify these values yourself, construct an OutputStreamWriter on a
FileOutputStream.
Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular,
allow a file to be opened for writing by only one FileWriter (or other file-writing object) at a time. In such situations
 the constructors in this class will fail if the file involved is already open.

FileWriter is meant for writing streams of characters. For writing streams of raw bytes, consider using a FileOutputStream.

Удобный класс для записи символьных файлов. Конструкторы этого класса предполагают, что кодировка символов по умолчанию и размер
 байтового буфера по умолчанию являются приемлемыми. Чтобы указать эти значения самостоятельно, создайте OutputStreamWriter для
  FileOutputStream.
Доступен ли файл или может быть создан, зависит от базовой платформы. В частности, некоторые платформы позволяют открывать файл
 для записи только одним FileWriter (или другим объектом записи файлов) за раз. В таких ситуациях конструкторы в этом классе
 потерпят неудачу, если соответствующий файл уже открыт.
FileWriter предназначен для написания потоков символов. Для записи потоков необработанных байтов рассмотрите возможность
использования FileOutputStream.


Размещение файлов во внешнем хранилище

В прошлой теме мы рассмотрели сохранение и чтение файлов из каталога приложения. По умолчанию такие
файлы доступны только самому приложения. Однако мы можем помещать и работать с файлами из внешнего хранилища.
Это также позволит другим программам открывать данные файлы и при необходимости изменять.

Весь механизм работы с файлами будет таким же, как и при работе с хранилищем приложения. Ключевым отличием
здесь будет получение и использование пути к внешнему хранилищу через метод Environment.getExternalStorageDirectory()

Итак, пусть в файле activity_main.xml будет такая же разметка интерфейса:
С помощью выражения Environment.getExternalStorageDirectory() получаем доступ к папке приложения во внешнем хранилище и устанавливаем объект файла:

private File getExternalPath() {
    return(new File(Environment.getExternalStorageDirectory(), FILE_NAME));
}
Поскольку для чтения/записи во внешнее хранилище необходимы разрешения, то перед операциями сохранения и записи файла необходимо проверить наличие разрешений. Для этого определен метод checkPermissions(). При установке разрешений срабатывает метод onRequestPermissionsResult(), в котором в случае удачной установки разрешений для переменной permissionGranted задается значение true.

Чтобы использовать внешнее хранилище, также надо установить разрешения в файле манифеста AndroidManifest.xml:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.eugene.filesapp" >

    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    //............................
//-------------------------------------------------------------------------------------------------------------------------------
 добавка выпадающего списка

 <Spinner
        android:id="@+id/cities"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

В качестве источника данных, как и для ListView, для Spinner может служить простой список или массив, соданный программно,
 либо ресурс string-array. Взаимодействие с источником данных также будет идти через адаптер.
 В данном случае определим источник программно в виде массива в коде MainActivity:

Нам нужно получить выбранный пользователем пункт в компоненте Spinner при помощи метода setOnItemSelectedListener()
 и реализовать метод onItemSelected() класса AdapterView.OnItemSelectedListener:
Теперь при выборе любого пункта вы получите всплывающее сообщение о выбранном пункте. Обратите внимание, что нам
 также пришлось реализовать вызов обратного вызова onNothingSelected().

В начале статьи показывался более простой способ с использованием метода getSelectedItem(), который достаточен для
большинства случаев.



* */

package com.example.myapplication;


import android.Manifest;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.Uri;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.provider.Settings;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.DialogFragment;
import android.support.v4.content.ContextCompat;
import android.support.v4.content.res.ResourcesCompat;
import android.support.v4.widget.SimpleCursorAdapter;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.view.ContextThemeWrapper;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.example.engine.mCircle;
import com.example.engine.mScene;
import com.example.engine.mSurfaceView;

import org.json.JSONException;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static java.lang.Thread.sleep;


public class MainActivity extends AppCompatActivity implements View.OnClickListener, View.OnTouchListener {


    Socket socket = null;
    private static final String TAG ="";
    private ParseContent parseContent = new ParseContent(this);
    private ListView listView;   // в функции приетма Json анных с сайта
    private final int jsoncode = 1;// там же
    private ValuesApplication playersModelArrayList;
    private CustomeAdapter customeAdapter;

    //} implements View.OnTouchListener { // интерфейс для касания по экрану.
    byte blink; // глбальная перееменная для мигания всех блоков в потоке
    float x; //переменные для приема координаткасания на мониторе
    float y;
    String sDown;     // переменные для вывода координат
    String sMove;
    String sUp;
    mSurfaceView mainview;
    mScene scene;
    mCircle cikle;
    //Image pict = new Image(R.drawable.);
    TextView tv;
    ImageView imgTouch; // переменная привязанная к рисунку
    Logika logika = new Logika();    // Объект основного класса.
    private ImageView imageView;                //Создание объекта для работы с картинками
    DatabaseHelper databaseHelper;   // БД
    SQLiteDatabase db;               // Для работы  с базой данных
    Cursor userCursor;               // Курсор для получения данных из БД в виде курсора
    SimpleCursorAdapter userAdapter; // В качестве данніх используется БД с помощью Cursor
    //-------------------------------------------Элементы для индикации-----------------------------------------------------
    TextView n_zad_text;     // N# - для вывода над блоком  данные из БД
    TextView n_zad_max;      // N#-max
    TextView n_zad_min;      // N#-мин
    TextView TempZI_RS_plus; // ТемпЗИ-РС'+'
    TextView n_zad_ZI;       // N#R
    //TextView n_zad_text;     // N#
    TextView Lz;             // L#
    TextView L;              // L
    TextView Skor ;          // N
    TextView Id;             // Id
    TextView Ud ;            // Ud


    ValuesApplication update_withDB;
    List m = new ArrayList();            // Суммарно добавляем все массивы
    ArrayList message = new ArrayList(); // принимаем ст роковые ресурс глобально именно по этому активити
    //int[] message1 = new int[40];
    int i = 0;   // Счетчик для последовательного отображения массивов диагностики
    int i_n = 0;   // Счетчик для последовательного отображения массивов наладки
    int i_a = 0;

    ////ипользуем диинамический массив
    //List<Integer> message = new ArrayList<Integer>();

    // Для сообщений наладка, определены внизу функции
    ArrayList messages_naladka = new ArrayList();


    //--------------------------------------------------------Кнопки для открытия нижних активити----------------------------
    Button sifu;
    Button n_zad;
    Button n_zad_R;

    //------------------------------------------------------Конфигурационные кнопки-------------------------------------------
    Button diagnostics;
    Button naladka;                                              // мастер настройки преобразователя

    //----------Окно для ревизии содержимого файлов-----------------------------------------
     EditText  outputText;

    //----------------------------Переменные для сети -------------------------------------
    String wifis[];                            // Строковый массив для списка сетей
    Spinner lv;                               // Объект типа список
    int i_w;                                   // вспомогательная переменная
    private WiFiMonitor mWiFiMonitor;           //Объект WiFiMonitor, поиск сети, вывод доступных точек
    String networkSSID = "";//"ESP_D1B9C9";    // Логин - для соединения к сети
    String networkPass = "1234qwer";           // Пароль - для соединения к сети


    //Для работы с сокетом
    String message_socet ;      		            // Буффер на передачу с сокета
    String bufer;								// Буффео на передачу с сокета, дублирует чтоб не передавать одну и ту же инфу
    private  String     HOST      = "192.168.4.1";;//"10.10.0.109";//"192.168.4.1";"192.168.43.185  10.0.0.2 -  адрес эмулятора к локалке
    private  int        PORT      = 8080;   //9876;//
    static String SERVERIP = "192.168.4.1"; 	// Your computer IP address
    public static int SERVERPORT = 8080;        // Порт выше 1024 (специальных портов), если не рутирован
    PrintWriter out;							// Приемная переменная с потока на прием
    TextView textResponse, ResponseT, ResponseT1, ResponseH;                      // Компонент для вывода инфы с сокета на прием
    boolean FlagCancelled;						// Флаг для прерывания обработки потока в AsynkTask

    String contentText = null;                  //в процессе  принятия товета на запрос

    String[] split_str;                         // Переменная делит строку по ключу. Сортирует ответ запроса
    String resultStr;                           // Участвует в приема ответа на запрос
    String t, t1, h;
    byte revis = 0;                             // Переменная для потока открытого для считывания запроса. Так при чтении например

    Connection  mConnect ;       // класс для работы с сокетом

    //---------------------------- Для записи и разрешения----------------------------
    private final static String FILE_NAME = "content.txt";
    private static final int REQUEST_PERMISSION_WRITE = 1001;
    private boolean permissionGranted;
    //------------------------------------------------------------------------------
    ProgressDialog p;

    //Logika n_zad_o;   // в таком виде просто объявляется ссылка на объект и она содержит null, и она указывает что оина
    // еще неуказывает на реальиный объект.
    // Ниже происхоит резерв памяипод реальный объекти присваивает преременной ссылку на реальный объект.
    //n_zad_o = new Logika();  // Создание объекта класса логика, new - создает ссылку на объект, поэтому без нее будет
    // вылетать
    //Logika n_zad_o = new Logika();  // подобно указателю
   // имя класса за котрым следуют круглые скобки , указывает конструктор данного класса
    // Класс - это логическая конструкция. Объект - физичечкая сущность, т.е объект занимает память
    N_zad n_zad_o = new N_zad();
    // добавляю класс ZIS ?, потом может надо все это переместить в метод чтобы мусор подчичался
    ZIS zis_o = new ZIS();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //вывел часть структ. схемы в ImageView, масштабирование пго android:scaleType = centerCrop"
        // равномерно растягивает картинку, чтобы заполнить весь контейнер и обрезает лишнее.
        // ПОКА ТАК
        //Привязка переменной ImageView к виджету imageView.
        imgTouch = (ImageView)findViewById(R.id.imageView);
        //Привязка переменной
        tv = (TextView)findViewById(R.id.textView);

        imageView = findViewById(R.id.imageView);                       //Подвязка к SVG-картинке в приложении

//-------------------Индикация----------------------------------------------------------------------

        n_zad_text = (TextView)findViewById(R.id.n_zad_text);           // N#
        n_zad_max = (TextView)findViewById(R.id.n_zad_max);             // N#-max
        n_zad_min = (TextView)findViewById(R.id.n_zad_min);             // N#-min
        TempZI_RS_plus = (TextView)findViewById(R.id.TempZI_RS_plus);   // ТемпЗИ-РС'+'
        n_zad_ZI = (TextView)findViewById(R.id.n_zad_ZI);               // N#R
        n_zad_text = (TextView)findViewById(R.id.n_zad_text);           // N#
        L = (TextView)findViewById(R.id.L);                             // L
        Lz = (TextView)findViewById(R.id.Lz);                           // L#
        Skor = (TextView)findViewById(R.id.skor);                       // N
        Id = (TextView)findViewById(R.id.Id);                             // Id
        Ud = (TextView)findViewById(R.id.Ud);                           // Ud

//----------------------------------Конфигурация-------------------------------------------------------------------
        diagnostics = (Button)findViewById(R.id.diagnostics);
        naladka = (Button)findViewById(R.id.naladka);


//----------------------------Интерактивность-------------------------------------------------------
        sifu = (Button)findViewById(R.id.sifu); // Блок сифу
        n_zad =  (Button)findViewById(R.id.n_zad);
        //sifu.setVisibility(View.INVISIBLE);       //To set visible - видимая для программы
        n_zad_R = (Button)findViewById(R.id.n_zad_R); // Открытие блока ЗИС

//---------------ревизия содержимого----------------------------------------------------------------
        outputText = findViewById(R.id.audit);
//---------список доступных wi-fi соединений--------------------------------------------------------
        lv = findViewById(R.id.list_wifi); 									 //Список доступных сетей


//------------------------------Обработка события---------------------------------------------------

        diagnostics.setOnClickListener(this);
        naladka.setOnClickListener(this);
        sifu.setOnClickListener(this);
        sifu.setOnTouchListener(this);
        n_zad.setOnTouchListener(this);
        n_zad_R.setOnTouchListener(this);

        enableWifi() ;                                                       //Проверяем включен ли WiFi, если нет то включаем
        bindToNetwork();                          							//Для версии выше 5, для связки процесса с сетью  (без интернет доступа)
        mWiFiMonitor = new WiFiMonitor();		  							//Создание объекта mWiFiMonitor, для работы с сетью
        IntentFilter intentFilter = new IntentFilter(); 					//Создаем объект для отслеживания изменений в сети.
        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);	//Произошло изменение сетевого подключения. IntentFilter должен содержать событие.
        registerReceiver(mWiFiMonitor, intentFilter);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            requestPermissions(new String[]{Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION}, 1);
        }


        //Установка обработчика для события касания на картинке.
        imgTouch.setOnTouchListener(new View.OnTouchListener()
        {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                /*
                * Объект класса MotionEvent используется для сообщения о событиях перемещения
                * (мыши, пера, пальца, трекбола). Motion events (события перемещения)
                 * могут содержать либо абсолютные, либо относительные перемещения и другие данные,
                  * в зависимости от типа устройства.
                * */
                //Методы getX и getY дают нам X и Y координаты касания. Метод getAction дает тип события касания:
                x = event.getX();
                y = event.getY();
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN: // нажатие
                        sDown = "Down: " + x + "," + y;
                        sMove = ""; sUp = "";
                        break;
                    case MotionEvent.ACTION_MOVE: // движение
                        sMove = "Move: " + x + "," + y;
                        break;
                    case MotionEvent.ACTION_UP: // отпускание
                    case MotionEvent.ACTION_CANCEL:
                        sMove = "";
                        sUp = "Up: " + x + "," + y;
                        break;
                }
                tv.setText(sDown + "\n" + sMove + "\n" + sUp);
                /*
   //----------------------------------------------------------------------------------------------------------------
                Немного пояснений к коду. Поскольку обработчик onTouch определен только для картинки imgSwitch,
                 то он будет срабатывать только на касания картинки. Внутри обработчика вызов v.getHeight()
                  даст высоту картинки, а вызов event.getY() даст координату касания по вертикали относительно
                  верхнего края картинки. Т. е. касание до верхнего края картинки даст координату 0,
                  а касание до нижнего края картинки даст координату v.getHeight()-1.
                  Чтобы определить, к какой половине картинки было произведено касание, используется условный оператор
                  if, который сравнивает координату касания с половиной от высоты картинки.
                   Если меньше половины высоты, то касание было в верхней части "выключателя",
                    и будет показана картинка для состояния ON. Если больше половины высоты, то значит касание
                     в нижней части, и будет показана картинка для состояния OFF.
                int touchY = (int)event.getY();
                if (touchY < v.getHeight()/2){;}
                {
                    imgTouch.setImageResource(R.drawable.switch_on);
                }
                else
                {
                    imgSwitch.setImageResource(R.drawable.switch_off);
                }
                return false;
  //-----------------------------------------------------------------------------------------------------------------------
                [Пример: определение места касания экрана]
                Для того, чтобы определить место касания экрана в программе Android, переопределите метод onTouchEvent для в классе Activity:
                @Override
                public boolean onTouchEvent(MotionEvent ev)
                {
                    textDebug.append(Float.toString(ev.getX())
                        + " "
                        + Float.toString(ev.getY())
                   +"\n");
                    return true;
                }
//-------------------------------------------------------------------------------------------------------------------------
                */
                return true;
            }
        });


//-------------------------пока движок положил в долгий ящик. не могу запихнуть хмл в сцену -------------------------------
        // -------------------------------------Начальные настройки движка--------------------------

       /* mSettings.AutoScale = true;        // Флаг автоматического изменения размера изображений при загрузке
        mSettings.setDefaultRes(480, 800); // Устновка разрешения по умолчанию
        mSettings.Init(this, this.getWindowManager().getDefaultDisplay(), 20); //  Инициализация движка. Контекст, дисплей, фреймрейт к которому должен стремиться движок

         обозначение количества кадров видеоряда за единицу времени, (единицей измерения служит количество кадров в секунду,
         обозначаемое fps (англ. frames per second) эквивалентное с-1, Гц).
        scene = new mScene(0, 0, 2);        // создаем сцену с двумя слоями, ее ширина и высота настроятся автоматически в классе mSurfaceView
        scene.setCurLay(1);                 // Устанавливаем в сцене текущим слоем первый слой (нумерация слоев с нуля) - для объектов
        scene.setCurLay(0);                 // устанавливаем самый нижний слой сцены как текущий -  для фона
        //scene.addItem(new mSimpleSprite("bg.png", this.getAssets()));    // На него добавляем фоновую картинку
        // используем для доступа к ресурсам
        //  scene.addItem(new mSimpleSprite(getResources(), R.drawable.ic_launcher));   // данная конструкция работает, только с png
        scene.addItem(new mSimpleSprite(getResources(), R.layout.activity_main));   -  вылетает приложение

        // Инициализируем поверхность
        mainview = new mSurfaceView(this, scene);
        this.setContentView(this.mainview);
        mainview.setOnTouchListener(this);  */
//----------------------------------------------------------------------------------------------------------------
//--------------------------------------------OnCreate------------------------------------------------------------

        final ContextThemeWrapper wrapper = new ContextThemeWrapper(this, R.style.LigthOff); /* Создаем новую оболочку контекста с указанной темой.
		Для работы с рисунком - лампочки выключены.*/
        /* themeResId - int: the resource ID of the theme to be applied on top of the base context's theme
        (идентификатор ресурса темы, который будет применяться поверх темы базового контекста)*/
        changeTheme(wrapper.getTheme());          							//Вернуть объект Тема, связанный с этим Контекстом

//----------------------------------------------------------БД-------------------------------------------------------------------
        databaseHelper = new DatabaseHelper(getApplicationContext());
        // создаем базу данных
        databaseHelper.create_db();

//-------Создание экземпляра класса.   - не заработал
       // update_withDB = new ValuesApplication();

        /*
        * Метод onCreate() нам не нужен, так как нам не требуется создание встроенной базы данных.
        * Зато здесь определен дополнительный метод create_db(), цель которого копирование базы данных
        * из папки assets в то место, которое указано в переменной DB_PATH.
          Кроме этого здесь также определен метод открытия базы данных open() с помощью метода SQLiteDatabase.openDatabase()
        *        *        * */

//-------------------------------------------------------------------------------------------------------------------
    //---------------
         //мИГАНИЕ
         blinkTextView();
        //--------------------------------------------------------------------------------------
/*Прослушивание событий элемента ListView. Нам нужно реагировать на определенные события, генерируемые элементом ListView, в частности, нас интересует событие,
которое возникает, когда пользователь нажимает на один из пунктов списка. В этом нам поможет метод setOnItemClickListener элемента ListView и метод OnItemClick() интерфейса AdapterView.OnItemClickListener.*/
        //Для Spinner использ. другой обработчик
        lv.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            public void onItemSelected(AdapterView<?> parent, View itemSelected, int position,
                                    long id) {
                /* где (AdapterView<?> parent - где произошел щелчок, View view - Vвид в клиенте AdapterView (это будет представление, предоставленное адаптером)
                int position - Позиция вида в адаптере., id    long: The row id of the item that was clicked - идентификатор строки элемента, который был нажат*/
                Toast.makeText(getApplicationContext(), ((TextView) itemSelected).getText(),
                        Toast.LENGTH_SHORT).show();
                networkSSID = (String) ((TextView) itemSelected).getText();
                checkSystemWritePermission();
                //Toast.makeText(this, "Write allowed :-)", Toast.LENGTH_LONG).show();
                // ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
                // if (cm == null) {
                // txt.setText("Отсутствует соединение");
                // }
                //myConnect();
                connectToWiFi(networkSSID);

                //bindToNetwork();
                //  Settings.Global.putInt(getContentResolver(), Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED, 0); //отключение проверки на подключение сетик интернету

                Toast.makeText(getApplicationContext(), ((TextView) itemSelected).getText(),
                        Toast.LENGTH_SHORT).show();
            }
            public void onNothingSelected(AdapterView<?> parent) {
            }
        });



    }

    //добавляем меню, после oncreate, Добавляем в заготовку метод, который берёт данные из ресурсов
    // меню и преобразует их в пункты меню на экране.
/*
* В методе inflate() вы указываете ресурс меню (R.menu.menu_main) и объект класса Menu.
По английски "inflate" переводится как надувать, т.е. по замыслу разработчиков Android, мы как
бы надуваем данными объект, например, меню. Но на самом деле слово "inflate" происходит от
 словосочетания in flat - в квартиру. Существует старинная традиция запускать в квартиру первым кота,
 который исследует все закоулки дома и заявляет о своём согласии жить в нём. Так и мы запускаем
 данные из XML-файла в объект MenuInflater.
*
*
* */
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {

        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.main_menu, menu);

        return super.onCreateOptionsMenu(menu);
    }

    // Вызов диалога старого образца см. старый код CustomDialogFragment();  - вызывается по кнопке
    /*public void showDialog(View v) {
        CustomDialogFragment dialog = new CustomDialogFragment();
        dialog.show(getSupportFragmentManager(), "custom");
    }*/
    // пока к кнопке подвязал диалоговое собщение , данный клик вызываается  в конпке.
    public void showDialog(View v) {
        showDialog();  //
        //CustomDialogFragment dialog = new CustomDialogFragment();
        //dialog.show(getSupportFragmentManager(), "custom");
    }

    private void changeTheme( Resources.Theme theme) { // Resources.Theme - Этот класс содержит текущие значения атрибутов для определенной темы.
        /*Другими словами, тема представляет собой набор значений атрибутов ресурсов; они используются вместе с */
        final Drawable drawable = ResourcesCompat.getDrawable(getResources(), R.drawable.ic_structura, theme);//ResourcesCompat - Помощник для доступа к функциям в ресурсах.
        /*Возвращает объект с возможностью рисования, связанный с определенным идентификатором ресурса и созданный для указанной темы.
         Различные типы объектов будут возвращаться в зависимости от базового ресурса - например, сплошной цвет, изображение PNG,
         масштабируемое изображение и т. Д.  До уровня API 21 эта тема не будет применяться, и этот метод просто вызывает getDrawable (int).*/
        imageView.setImageDrawable(drawable);
    }
//--------------------------------------обработка нажатия кнопки-------------------------------------------------
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            // по нажатию просто мигаем блоком
            case R.id.sifu:
                //final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать с помощью методов в классе Resources, экземпляр которого можно получить с помощью метода getResources().
                //theme.applyStyle(R.style.LigthOn, false);
                //changeTheme(theme);
                ;
            break;

            case R.id.diagnostics:
        //        db.close();
                //db = databaseHelper.open(); //открываю БД
                // произвожу запрос определенного элемента
                // ВНИМАНИЕ курсор записывает базу так как видит т.е. 1-й будет не тот который запрашивается, а тот который идет в БАЗЕ.
                userCursor =  db.rawQuery("select * from " + DatabaseHelper.TABLE + " where " + DatabaseHelper.COLUMN_name + " = ? or " + DatabaseHelper.COLUMN_name + " = ? ", new String[] {(getString(R.string.r_Mashtab_ZSkA)),(getString(R.string.r_T_ZISkorP_Razg))}); /*r.T_ZISkorP_Razg*/
                userCursor.moveToFirst();
                Float var = userCursor.getFloat(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));
                ((ValuesApplication) this.getApplication()).setZSkA(var); // записываем данные
                userCursor.moveToNext();
                var = userCursor.getFloat(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));
                ((ValuesApplication) this.getApplication()).setr_T_ZISkorP_Razg(var); // записываем данные
                //update_withDB.UpdateWithDB(databaseHelper,db,userCursor);
                UpgradeActivityData();  // оБновляем активити с данными из локального хранилища

                //onResume(); -  вызов super.onResume() - Не безопасно
                //db.close();
                //TempZI_RS_plus.setText("'+' " + userCursor.getString(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values)) + " ном.");
   //------------------------пока не использую------------------------
                //В классе B метод static? Если да - то просто B.methodName(параметры). Если нет, то нужно сначала создать экземпляр класса
                //Т.к. метод не статическией то сначала экземпляр класса.

                //this.userCursor =  db.rawQuery("select * from " + DatabaseHelper.TABLE + " where " + DatabaseHelper.COLUMN_name + " = ? ", new String[] {"r.T_ZISkorP_Razg"});

                //После обновления данных вызываем логика которая обрабатывает последовательно все блоки от начала до конца
                // Итак обращаемся к классу логика
                //((ValuesApplication) this.getApplication()).getT_ZISkorP_Razg();
                //((ValuesApplication) this.getApplication()).setZ_Skor((float)1.0);

                break;
            //Обработка при наладке
            case R.id.naladka:
                //По нажатию вызываем создание диалоговог окна для мастера
                ActivityNaladka();
                break;
        }
    }


    //-------------------------------------------МЕНЮ!!!!!!!!!!!!!!---------------------------------
    /*истема вызывает метод onOptionsItemSelected() вашей операции. Этот метод передает выбранный класс
    MenuItem. Идентифицировать пункт меню можно, вызвав метод getItemId(), который возвращает уникальный
    идентификатор пункта меню
    main_menu.xml

    */
    public boolean onOptionsItemSelected(MenuItem item) {
        final MyClientTask myClientTask =  new MyClientTask();  //наподобие смартхауса Вынес за пределы Oncreate, т.к. слкет по видимоу создается слишком раго

        // Handle item selection
        switch (item.getItemId()) {
            case R.id.action_settings:
                Toast.makeText(getApplicationContext(),"Меню в разработке!", Toast.LENGTH_LONG).show();
                return true;
            case R.id.BD:
                Toast.makeText(getApplicationContext(),"Пока по умолчанию!", Toast.LENGTH_LONG).show();
                return true;
            //Чтение данных из файла
            case R.id.JSON:
                runReadJson();
                return true;
            //Чтение данных из нтернетстраницы
            case R.id.webJSON:
                try {
                    runReadWebJson();
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (JSONException e) {
                    e.printStackTrace();
                }
                return true;
            // Открытие файла для просмотра данных
            case R.id.openFile:
                openText();
                return true;

            case R.id.search_wifi:
                //производим поиск сетей по нажатию на кнопку
                final WifiManager wifi = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE);
                ScanReceiver scanReceiver = new ScanReceiver(); //
                registerReceiver(scanReceiver, new IntentFilter(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION));
                wifi.startScan();
                return true;
            case R.id.read_data:
                //onStop();
                //myClientTask.execute();

                /* Освобождаем ресурсы */
                //mConnect.closeConnection();
                closeConnection();
                //onOpenClick();
                new AnotherThread();

                return true;

            case R.id.Stop_Net:
                //Убрано this- проверить
                //ConnectivityManager connectivityManager = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE);
                ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    connectivityManager.bindProcessToNetwork(null);
                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    connectivityManager.setProcessDefaultNetwork(null);
                }
                return true;

            case R.id.StopData:
                //Закрытие сокета
                //mConnect.closeConnection();
                closeConnection();
                //myClientTask.cancel(true);// не срабатывает ввожу флагъ
                //onStop();
                return true;

            case R.id.Clear:
                outputText.setText("");
                return true;


            //case R.id.help:
            //    showHelp();
            //    return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }


    protected void onResume() {
        super.onResume();
        //  Злесь выташим данные из БД. И засуним их в TextView над блоками.
        // эделаем запрос к базе/ Работа скурсором

        db = databaseHelper.open(); //открываю БД
        // произвожу запрос определенного элемента
        userCursor =  db.rawQuery("select * from " + DatabaseHelper.TABLE + " where " + DatabaseHelper.COLUMN_name + " = ?or "+ DatabaseHelper.COLUMN_name + "  = ? or " + DatabaseHelper.COLUMN_name + " = ? ", new String[] {"Z_Skor","_r.Z_SkMax_P","_r.Z_SkMax_M"});
        //userCursor =  db.rawQuery("select * from "+ DatabaseHelper.TABLE, null);
        userCursor.moveToFirst();// - необходимо курсором перейтик строке , так как если не перейти, то она будет
        // не выделена, и в случае передачи данных н
        //не адаптерку, а например элементу - краш
        // по ходу при передачи адаптеру указатель не нужен
        //извлекаю из курсора
        //int item_id = userCursor.getInt(userCursor.getColumnIndex(DatabaseHelper.COLUMN_ID)); -  краш
        //n_zad_text.setText("Н" + String.valueOf(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values))); - выдает 2,
        // рпботате без указателя
        //n_zad_text.setText("Н" + String.valueOf(userCursor.getCount())); //  выдает 1
        //n_zad_text.setText("Н" + String.valueOf(userCursor.getColumnIndex(DatabaseHelper.COLUMN_name))); //- выдает 1
        //n_zad_text.setText("Н" + String.valueOf(userCursor.getColumnIndex(DatabaseHelper.COLUMN_ID))); //- при любой
        // переменной выдает 0
        //String item_content = userCursor.getString(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));//
        // так передает значение первой строки. как имени так и значения
        //когда присутствует userCursor.moveToFirst();  - без него крашится
        n_zad_text.setText("N# "+userCursor.getString(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values)) + " ном");



        //String item_content = userCursor.getString(userCursor.getColumnIndex("name"));// так вылетает ошибка
        //String item_id = userCursor.getString(userCursor.getColumnIndex("Z_Skor")); - краш
        /*cursor.getColumnIndex(имя поля); он возвращает индекс столбца поля в выписке select cursor.getString(индекс столбца).
         он возвращает значение, которое находится в этом столбце*/
        // привязываю к текстовому элементу
       // n_zad_text.setText(item_content);
        //------------------------------------------------привязка к ограничению-----------------------------------------


        userCursor.moveToNext();
        n_zad_min.setText("N#-min "+userCursor.getString(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values)) + " ном");


        userCursor.moveToNext();
        n_zad_max.setText("N#-max "+userCursor.getString(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values)) + " ном");


        db.close();
        userCursor.close();
        db = databaseHelper.open(); //открываю БД

        //userCursor =  db.rawQuery("select * from " + DatabaseHelper.TABLE + " where " + DatabaseHelper.COLUMN_name + " = ? ", new String[] {"r.T_ZISkorP_Razg"});
        //userCursor.moveToFirst();
        //String var = userCursor.getString(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));

        // Читаю БД для ЗИС
        userCursor =  db.rawQuery("select * from " + DatabaseHelper.TABLE + " where " + DatabaseHelper.COLUMN_name + " = ?or "+ DatabaseHelper.COLUMN_name + "  = ? or " + DatabaseHelper.COLUMN_name + " = ?or "  + DatabaseHelper.COLUMN_name + " = ? ", new String[] {"r.T_ZISkorP_Razg","_r.T_ZISkorP_Torm","_r.T_ZISkorP_Fors","ZISkor"});
        //userCursor =  db.rawQuery("select * from "+ DatabaseHelper.TABLE, null);
        userCursor.moveToFirst();

        Float var = userCursor.getFloat(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));
        ((ValuesApplication) this.getApplication()).setr_T_ZISkorP_Razg(var);

        userCursor.moveToNext();
        var = userCursor.getFloat(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));
        ((ValuesApplication) this.getApplication()).setr_T_ZISkorP_Torm(var);

        userCursor.moveToNext();
        var = userCursor.getFloat(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));
        ((ValuesApplication) this.getApplication()).setr_T_ZISkorP_Fors(var);

        //Пока закоментил чтоб не читать данные из БД, а из json
        //userCursor.moveToNext();
        //var = userCursor.getFloat(userCursor.getColumnIndex(DatabaseHelper.COLUMN_values));
        //((ValuesApplication) this.getApplication()).setZISkor(var);


        // потом это удалить
        // пример использоыввани из класса где будут сидеть мои переменные в процессе
        // set
        ((ValuesApplication) this.getApplication()).setSomeVariable("foo");
        // get
        String s = ((ValuesApplication) this.getApplication()).getSomeVariable();
        // Происходил краш, т.к. сласс в манифесте был объявлен в конце

    }

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        switch (v.getId()) {
            // по нажатию просто мигаем блоком

            case R.id.sifu:
                //final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать
                // с помощью методов в классе Resources, экземпляр которого можно получить с помощью метода getResources().
                //theme.applyStyle(R.style.LigthOn, false);
                //changeTheme(theme);
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN: // нажатие
                        final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно
                        // получать с помощью методов в классе Resources, экземпляр которого можно получить с помощью
                        // метода getResources().
                        theme.applyStyle(R.style.LigthOn, false);
                        changeTheme(theme);

                        break;
                    case MotionEvent.ACTION_UP: // отпускание
                        final Resources.Theme theme1 = getResources().newTheme();//Отдельные ресурсы также можно
                        // получать с помощью методов в классе Resources, экземпляр которого можно получить с
                        // помощью метода getResources().
                        theme1.applyStyle(R.style.LigthOff, false);
                        changeTheme(theme1);
                        // по отпусканию открываем активити для сифу
                        Intent intent = new Intent(this, Sifu.class); //вызов второй активности
                        startActivity(intent);
                        break;
                }
                break;
            case R.id.n_zad:
                //final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать
                // с помощью методов в классе Resources, экземпляр которого можно получить с помощью метода getResources().
                //theme.applyStyle(R.style.LigthOn, false);
                //changeTheme(theme);
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN: // нажатие
                        final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать
                        // с помощью методов в классе Resources, экземпляр которого можно получить с помощью метода
                        // getResources().
                        theme.applyStyle(R.style.BlickOn_n_zad, false);
                        changeTheme(theme);

                        break;
                    case MotionEvent.ACTION_UP: // отпускание
                        final Resources.Theme theme1 = getResources().newTheme();//Отдельные ресурсы также можно
                        // получать с помощью методов в классе Resources, экземпляр которого можно получить с помощью
                        // метода getResources().
                        theme1.applyStyle(R.style.BlickOff_n_zad, false);
                        changeTheme(theme1);
                        // по отпусканию открываем активити для задания скорости.
                        Intent intent = new Intent(this, N_zad.class); //вызов второй активности
                        startActivity(intent);
                        break;
                }
                break;
            case R.id.n_zad_R:
                //final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать
                // с помощью методов в классе Resources, экземпляр которого можно получить с помощью метода getResources().
                //theme.applyStyle(R.style.LigthOn, false);
                //changeTheme(theme);
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN: // нажатие
                        final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать
                        // с помощью методов в классе Resources, экземпляр которого можно получить с помощью метода
                        // getResources().
                        theme.applyStyle(R.style.BlickOn_zis, false);
                        theme.applyStyle(R.style.BlickOn_lms, false);

                        changeTheme(theme);

                        break;
                    case MotionEvent.ACTION_UP: // отпускание
                        final Resources.Theme theme1 = getResources().newTheme();//Отдельные ресурсы также можно
                        // получать с помощью методов в классе Resources, экземпляр которого можно получить с помощью
                        // метода getResources().
                        theme1.applyStyle(R.style.BlickOff_zis, false);
                        theme1.applyStyle(R.style.BlickOff_lms, false);
                        changeTheme(theme1);
                        // по отпусканию открываем активити для задания скорости.
                        Intent intent = new Intent(this, ZIS.class); //вызов второй активности
                        startActivity(intent);
                        break;
                }
                break;

        }
        return false;
    }

    //-------------------------------Обработка нажаттия кнопки по нажатию и отпусканию----------------------------------




//-------------------------- для движка, пока отложил------------------------------------------------------------
    // Обрабатываем нажатие на экран. По нажатию добавляем круг
    /*@Override
    public boolean onTouch(View v, MotionEvent evt) {
        // запоминаем координату куда
        // пользователь опустил палец
        int x = (int) evt.getX();
        int y = (int) evt.getY();
        scene.setCurLay(1);
        cikle = new mCircle(x,y,30);
        scene.addItem(cikle);
        return true;
    }*/
//-------------------------------------------------------------------------------------------------------

//---------------------------Обновление данных из БД по клику диагностика и сама диагностика-----------------------------
// просто перезапись в элементы текствью, обновить вид активити
    public void UpgradeActivityData(){
        //int i = 0;
        Float var =  ((ValuesApplication) this.getApplication()).getr_T_ZISkorP_Razg();
        TempZI_RS_plus.setText("'+' " + var + " ном.");
        var =  ((ValuesApplication) this.getApplication()).getZISkor();
        n_zad_ZI.setText("N#R " + var + " ном.");
        var =  ((ValuesApplication) this.getApplication()).getZ_Skor();
        n_zad_text.setText("N# " + var + " ном.");
        var =  ((ValuesApplication) this.getApplication()).get_L();
        L.setText("L " + var + " град");
        var =  ((ValuesApplication) this.getApplication()).get_Lz();
        Lz.setText("L# " + var + " град");
        var =  ((ValuesApplication) this.getApplication()).get_N();
        Skor.setText("N " + var + " ном.");
        var =  ((ValuesApplication) this.getApplication()).get_Id();
        Id.setText("Id " + var + " ном.");
        var =  ((ValuesApplication) this.getApplication()).get_Ud();
        Ud.setText("Ud " + var + " ном.");



        //--------------------------блок задания скорости ----------------------------------------------
        // 1. тпроверка логики
        // //------------------------------------------
        // вызываю параметры класса , передаю им значения для обработки логики и получаю результат
        // данный результат будет передавать строки для диалогового окна заглавление и сообщение
        //1. передаю аргументы
        n_zad_o.r_Mashtab_ZSkA = ((ValuesApplication) this.getApplication()).get_r_Mashtab_ZSkA();
        n_zad_o.ZSkA = ((ValuesApplication) this.getApplication()).getZSkA();
        n_zad_o.Z_Skor = ((ValuesApplication) this.getApplication()).getZ_Skor();

        message = n_zad_o.Complete_N_zad(n_zad_o.ZSkA, n_zad_o.r_Mashtab_ZSkA, n_zad_o.Z_Skor);

        //for( int i = 0; i < message.length; i++){
            //m.add(message[i]);
            //int t;
            //t = message[i];
            m.addAll(message);
        //}

        //m.add(message[0]);
        //m.add(message[1]);

        zis_o.Z_Skor = n_zad_o.ZSkA;
        zis_o.ZISkor =  ((ValuesApplication) this.getApplication()).getZISkor();
        zis_o.r_T_ZISkorP_Razg =  ((ValuesApplication) this.getApplication()).getr_T_ZISkorP_Razg();
        zis_o.r_T_ZISkorP_Torm =  ((ValuesApplication) this.getApplication()).getr_T_ZISkorP_Torm();
        zis_o.r_T_ZISkorP_Fors =  ((ValuesApplication) this.getApplication()).getr_T_ZISkorP_Fors();

        zis_o.ZIS(zis_o.Z_Skor,zis_o.ZISkor,zis_o.r_T_ZISkorP_Razg, zis_o.r_T_ZISkorP_Torm,zis_o.r_T_ZISkorP_Fors);
        ///message.clone();
        message = zis_o.Complete_NzAndNzR();
        // прочесываем второй класс например ЗИС
        //

        //for( int i =0 ; i < message.length; i++){
          //  int t;
           // t = message[i];

            m.addAll(message);
        //}
        //m.add(message);
        //m.add(new zis_o);

        // какой-то приветственный диалог . можно и убрать
        DialogFragment newFragment = CustomDialogFragment.newInstance(
                R.string.alert_dialog_two_buttons_title, "Начать диагностику?",1);
        Log.i("FragmentAlertDialog", "show dialog");
        newFragment.show(getSupportFragmentManager(), "dialog");
    }

//-------------------------------------------------------------------------------------------------------------

    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
    }
    private void ActivityNaladka() {


        //------Набираем наименование диалогов---------------------------------------
        messages_naladka.add (R.string.naladka_dialog);
        messages_naladka.add (R.string.naladka_dialog_cheredov);
        messages_naladka.add (R.string.naladka_dialog_fazirV);
        messages_naladka.add (R.string.naladka_dialog_fazirY);
        messages_naladka.add (R.string.naladka_dialog_RTY);

        //создаем свою форму диалога
        // какой-то приветственный диалог . можно и убрать
        DialogFragment newFragment = CustomDialogFragment.newInstance(
                R.string.alert_dialog_free_buttons_title, getString((Integer) messages_naladka.get(i_n)),2);
        newFragment.show(getSupportFragmentManager(), "dialog");

    }
    //-------------------------------------------------------------------------------------------------


    //------------------------------Функция выводящая диалог для диагностики------------------------
    void nextDialogD () {
        //if ((Integer)m.get(i) > 0 ){
        // данный вариант пролистывает по кругу сообщения. Все ОК.
            CustomDialogFragment newFragment = CustomDialogFragment.newInstance(
                    R.string.alert_dialog_start, getString((Integer) m.get(i)),1);
            newFragment.show(getSupportFragmentManager(), "dialog");
            i++;
            if (i>=m.size()){
                i=0;
                return;
            }
        //}
        /*if (message[i] != 0){
            // после этого вызываю диалог с определенными строками
            DialogFragment newFragment = CustomDialogFragment.newInstance(
                    R.string.alert_dialog_start, getString(message[i]));
            newFragment.show(getSupportFragmentManager(), "dialog");
        i++;
            if (i>=20){
                i=0;
            }
        }*/
    }

    //------------------------------Функция выводящая диалог для наладки ---------------------------
    void nextDialogN () {
        //if ((Integer)m.get(i) > 0 ){
        // данный вариант пролистывает по кругу сообщения. Все ОК.
        i_n++;
        if (i_n>=messages_naladka.size()){
            i_n=0;
            return;
        }
        DialogFragment newFragment = CustomDialogFragment.newInstance(
                R.string.alert_naladka_start, getString((Integer) messages_naladka.get(i_n)),2);
        newFragment.show(getSupportFragmentManager(), "dialog");



        //}
        /*if (message[i] != 0){
            // после этого вызываю диалог с определенными строками
            DialogFragment newFragment = CustomDialogFragment.newInstance(
                    R.string.alert_dialog_start, getString(message[i]));
            newFragment.show(getSupportFragmentManager(), "dialog");
        i++;
            if (i>=20){
                i=0;
            }
        }*/
    }
//--- выводит активити соотв. диалогу-----------------------------------------
    void showActivity(){
        if (messages_naladka.get(i_n).equals(R.string.naladka_dialog_cheredov)){
            Intent intent = new Intent(this, Cher_faz.class); //вызов второй активности
            startActivity(intent);
        }

        if (messages_naladka.get(i_n).equals(R.string.naladka_dialog)){
            Toast.makeText(getApplicationContext(),"Выбирите продолжить или отмена!  ", Toast.LENGTH_LONG).show();
        }
    }

//----------------------------Закрытие БД-------------------------------------------------------------------------------
    // ПОСЛЕ ВЫХОДА ИЗ ПРИЛОЖЕНИЯ НЕОБХОДИМО ЗАКРЫТЬ ЕЕ.
    @Override
    public void onDestroy(){
        super.onDestroy();
        // Закрываем подключение и курсор
        db.close();
        userCursor.close();
    }

    //    вывод настраиваемого диалогового окна непосредственно обработка из кнопки
    void showDialog() {
        //передает два параметра, второй строрку как есть
        //DialogFragment newFragment = CustomDialogFragment.newInstance(
        //        R.string.alert_dialog_two_buttons_title, "edsdsd");

        // Если так то выдает всяку. хуйню, неможет преобразовать ресурс в строку, передает ее как цифры, а начальная строка
        // что я ее задаю перед ресурсам хавает
        //DialogFragment newFragment = CustomDialogFragment.newInstance(
        //        R.string.alert_dialog_two_buttons_title, "sdds" + R.string.alert_dialog_two_buttons_m );

//Ресурс - (DialogFragment) https://developer.android.com/reference/android/app/DialogFragment.html
        DialogFragment newFragment = CustomDialogFragment.newInstance(
                R.string.alert_dialog_two_buttons_title, getString(R.string.alert_dialog_two_buttons_m),1);
        //args.putString("phone", selectedPhone);
        //dialog.setArguments(args);
        newFragment.show(getSupportFragmentManager(), "dialog");   //getFragmentManager() - не видит
    }

    // Настраиваемые обрабочтики кнопок диалоового окна. -  "OK"
    public void doPositiveClickD() {
        // Do stuff here.
        nextDialogD();    // Начинаем пошаговый вывод диалога.
        Log.i("FragmentAlertDialog", "Positive click!");
    }
   //"Отмена"
    public void doNegativeClickD() {
        // Do stuff here.
        i = 0; // сбос счетчика вводящих диалоги
        Log.i("FragmentAlertDialog", "Negative click!");
    }
//----------------Кнопки для наладки-------------------------------------------------------
    public void doPositiveClickN() {
        nextDialogN();

        Log.i("FragmentAlertDialog", "Positive click!");
    }
    //"Отмена"
    public void doNegativeClickN() {
        // Do stuff here.
        i_n = 0; // сбос счетчика вводящих диалоги
        Log.i("FragmentAlertDialog", "Negative click!");
    }
    //
    public void doNeutralClickN() {
        // Вызов другой активности из диалога
        showActivity();
        Log.i("FragmentAlertDialog", "Neutral click!");
    }


//Мигание блока с несоответсвием в потоке
    private void blinkTextView() {
        final Handler handler = new Handler();
        final Resources.Theme theme = getResources().newTheme();//Отдельные ресурсы также можно получать

        new Thread(new Runnable() {
            @Override
            public void run() {
                int timeToBlink = 1000;
                try{
                    sleep(timeToBlink);}catch (Exception e) {}
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (blink == 0) {
                            theme.applyStyle(R.style.BlickOn_lms, false);
                            blink = 1;
                }
                        else {
                    theme.applyStyle(R.style.BlickOff_lms, false);
                    blink=0;
                }
                changeTheme(theme);
                blinkTextView();
            }
                });
            }
        }).start();
    }
    //public void runReadJson(View view)  {
      public void runReadJson()  {
            try {
            //Читаем данные с файла и зпихиваем в локальное хранилище
            ValuesApplication data = ReadJSONExample.readDataJSONFile(this);
            //Прочитанные даные выводи м на жэкраин пока для ревизии
            outputText.setText(data.toString());
        } catch(Exception e)  {
          //  outputText.setText(e.getMessage());
            e.printStackTrace();
        }
    }
    // Вызов функции из меню для чтения из интернет ресурса
    public void runReadWebJson() throws IOException, JSONException{
        // Проверка и подключение интернет соединения (класс AndyUtils)   и создание диалога
        if (!AndyUtils.isNetworkAvailable(MainActivity.this)) {
            Toast.makeText(MainActivity.this, "Internet is required!", Toast.LENGTH_SHORT).show();
            return;
        }
        Log.d("I_am","Hello"); // для отладки
        // создание потока для запроса и получение ответа
        //AndyUtils.showSimpleProgressDialog(MainActivity.this);  // создание окна загрузки
        new AsyncTask<Void, Void, String>(){
            protected String doInBackground(Void[] params) {
                String response="";   // Возврат ответа
                HashMap<String, String> map=new HashMap<>();
                try {
                    /*
                    * Following will call web service.
                        HttpRequest req = new HttpRequest(AndyConstants.ServiceType.URL);
                        response = req.prepare(HttpRequest.Method.POST).withData(map).sendAndReadString();
                        We will get JSON Data in String Format into variable named “response.”
                        These JSON Data is sent to onPostExecute(String result) method. Below is code of
                    * */
                    //запрос в класс е HttpRequest , адресс и посылаемые параметры формируем в классе  AndyConstants
                    HttpRequest req = new HttpRequest(AndyConstants.ServiceType.URL);
                    //получаем прарметры
                    //response = req.prepare(HttpRequest.Method.POST).withData(map).sendAndReadString();  // пока не использую ключи
                    response = req.prepare(HttpRequest.Method.POST).sendAndReadString(); // dsdjl
                    Log.d("I_am","Hello");
                } catch (Exception e) {
                    response=e.getMessage();
                }
                return response;
            }
            protected void onPostExecute(String result) {
                //do something with response
                Log.d("newwwss",result);
                onTaskCompleted(result,jsoncode);
                //Прочитанные даные выводи м на жэкраин пока для ревизии
                //ПРОСТО выводится строка не формат

                //  Так все работает
                //outputText.setText(result.toString()); // Полностью читаем данные . Читаь ниже чтоб загрыть загрузку
                //AndyUtils.removeSimpleProgressDialog();  // удаляем окно загрузки
            }
        }.execute();
    }
    //From above method, JSON Data is sent to the onTaskCompleted() method.
    public void onTaskCompleted(String response, int serviceCode) {
        Log.d("responsejson", response.toString());
        switch (serviceCode) {
            case jsoncode:
                // попробуем пропарсить данные
               // if (parseContent.isSuccess(response)) {   //Для проверки статуса, у меня в странице нету такого
                //AndyUtils.removeSimpleProgressDialog();  //will remove progress dialog
                    //outputText.setText(response.toString()); // Полностью читаем данные . Читаь ниже чтоб загрыть загрузку

                    // JSON Parsing in android is done by getInfo() method of
                       //playersModelArrayList = parseContent.getInfo(response); //- !!!Не работает
                    // customeAdapter = new CustomeAdapter(this,playersModelArrayList);
                    // listView.setAdapter();
                    //Читаем из интернет страницы
                    playersModelArrayList = parseContent.readDataJSONWeb(response);
                //((ValuesApplication) this.getApplication()) = playersModelArrayList;
                //((ValuesApplication) this.getApplication()).setZISkor((float)76.0);

                    //outputText.setText(response.toString()); // Полностью читаем данные . Читаь ниже чтоб загрыть
                // выводим данные которые отпарсили
                outputText.setText( playersModelArrayList.toString()); // Полностью читаем данные . Читаь ниже чтоб загрыть загрузку
                saveText(response); // Передаем данные в фай   ----ЗАПИСЬ
                // ----------------------------Попытка записывать -  нихера---------------------------------------
                //здесь же произведем запись, просто запись в файл
                /* Не работает
                FileWriter fWriter;
                File sdCardFile = new File(Environment.getExternalStorageDirectory() + " \filename.txt");
                Log.d("TAG", sdCardFile.getPath()); //<-- check the log to make sure the path is correct.
                try{
//                    fWriter = new FileWriter(sdCardFile, true);
                    fWriter = new FileWriter("filename.txt");

                    fWriter.write("hi");
                    fWriter.flush();
                    fWriter.close();
                    Toast.makeText(MainActivity.this, "Write", Toast.LENGTH_SHORT).show();
                }catch(Exception e){
                    e.printStackTrace();
                    Toast.makeText(MainActivity.this, "No Write", Toast.LENGTH_SHORT).show();
                }*/

                //Finally, as flush() is called by close(), calling flush() immediately prior to close() is superfluous,
                // though not harmful.
                //}else {
                    //Toast.makeText(MainActivity.this, parseContent.getErrorCode(response), Toast.LENGTH_SHORT).show();
                //}

                /*
                * You need to call sync() before closing the file, but you need a FileDescriptor for that, and I don't believe
                * it's available directly from FileWriter. However, you can create a FileWriter object using a FileDescriptor,
                * and FileOutputStream can provide one for this purpose.

The following is based on your initial code, but I've opted to store the file on the sdcard in my example, so to run the
code below as is your app manifest will need the correct permission added prior to the <application> tag.

<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
That said, the outcome won't be affected if you want store the file on the device directly.

Code (tested on a Desire HD):
                *
                * */
              /*
              Не заходит в запись файла может потому что нет разрешения
              FileOutputStream fos ;

                try {
                    fos = new FileOutputStream("/sdcard/filename.txt", true);

                    FileWriter fWriter;

                    try {
                        fWriter = new FileWriter(fos.getFD());
                        fWriter.write("hi");
                        fWriter.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        fos.getFD().sync();
                        fos.close();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    Toast.makeText(MainActivity.this, "No Write", Toast.LENGTH_SHORT).show();
                }*/
//--------------------------Конец попытки записи - ихера -----------------------------------------

        }
    }

   /* //конвертированире объекта в данные
    public void runExample(View view)  {
        try {
            StringWriter output = new StringWriter();

            Company company = JsonWriterExample.createCompany();


            JsonWriterExample.writeJsonStream(output, company);

            String jsonText = output.toString();

            outputText.setText(jsonText);
        } catch(Exception e)  {
            outputText.setText(e.getMessage());
            e.printStackTrace();
        }
    */
   //---------------------Чтение и запись во внешнее хранилище + получение разрешений.-----------------
   /*С помощью выражения Environment.getExternalStorageDirectory() получаем доступ к папке
    приложения во внешнем хранилище и устанавливаем объект файла:*/
   private File getExternalPath() {
       return(new File(Environment.getExternalStorageDirectory(), FILE_NAME));
   }
    // сохранение файла
    public void saveText(/*View view*/String response){

        if(!permissionGranted){
            checkPermissions();
            return;
        }
        FileOutputStream fos = null;
        try {

            //Вызов по кнопке EditText textBox = (EditText) findViewById(R.id.save_text);
            //String text = textBox.getText().toString();
            // Вытягиваем наши данные
            String text = playersModelArrayList.toString();
            // получаем путь + прикручиваем файл + права
            fos = new FileOutputStream(getExternalPath(),true);  //true - дозапись MODE_APPEND,  MODE_PRIVATE - false - с нуля
            //BufferedWriter Writer = new BufferedWriter(new OutputStreamWriter(openFileOutput(FILENAME, MODE_PRIVATE), "UTF-8"));

            //fos = openFileOutput(String.valueOf(getExternalPath()), /*MODE_PRIVATE*/MODE_APPEND);
            fos.write(text.getBytes());
            Toast.makeText(this, "Файл сохранен", Toast.LENGTH_SHORT).show();
        }
        catch(IOException ex) {

            Toast.makeText(this, ex.getMessage(), Toast.LENGTH_SHORT).show();
        }
        finally{
            try{
                if(fos!=null)
                    fos.close();
            }
            catch(IOException ex){

                Toast.makeText(this, ex.getMessage(), Toast.LENGTH_SHORT).show();
            }
        }
    }
    // открытие файла
    public void openText(/*View view*/){
        if(!permissionGranted){
            checkPermissions();
            return;
        }

        FileInputStream fin = null;
       //TextView textView = (TextView) findViewById(R.id.open_text);
        File file = getExternalPath();
        // если файл не существует, выход из метода
        if(!file.exists()) return;
        try {
            fin =  new FileInputStream(file);
            byte[] bytes = new byte[fin.available()];
            fin.read(bytes);
            String text = new String (bytes);
            outputText.setText(text);
        }
        catch(IOException ex) {

            Toast.makeText(this, ex.getMessage(), Toast.LENGTH_SHORT).show();
        }
        finally{

            try{
                if(fin!=null)
                    fin.close();
            }
            catch(IOException ex){

                Toast.makeText(this, ex.getMessage(), Toast.LENGTH_SHORT).show();
            }
        }
    }

    // проверяем, доступно ли внешнее хранилище для чтения и записи
    public boolean isExternalStorageWriteable(){
        String state = Environment.getExternalStorageState();
        return  Environment.MEDIA_MOUNTED.equals(state);
    }
    // проверяем, доступно ли внешнее хранилище хотя бы только для чтения
    public boolean isExternalStorageReadable(){
        String state = Environment.getExternalStorageState();
        return  (Environment.MEDIA_MOUNTED.equals(state) ||
                Environment.MEDIA_MOUNTED_READ_ONLY.equals(state));
    }

    private boolean checkPermissions(){

        if(!isExternalStorageReadable() || !isExternalStorageWriteable()){
            Toast.makeText(this, "Внешнее хранилище не доступно", Toast.LENGTH_LONG).show();
            return false;
        }
        int permissionCheck = ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE);
        //вернет PackageManager.PERMISSION_GRANTED, т.к. разрешения есть и ниже условие не выполнится и невызовет
        //onRequestPermissionsResult и не выставит флаг  permissionGranted. Поэтому программа более одного раза не выполнится.
        if(permissionCheck!= PackageManager.PERMISSION_GRANTED){
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_PERMISSION_WRITE);
            return false;
        }
        else{ //я добавляю
            permissionGranted = true;
        }
        return true;
    }
    /*
Каждый раз, когда мы хотим использовать метод, требующий опасного разрешения, необходимо проверить есть ли оно у нас.
Для этого используем метод ContextCompat.checkSelfPermission(Context context, String permission), который возвращает нам одно
из int значений: PackageManager.PERMISSION_GRANTED в случае если разрешение есть или PackageManager.PERMISSION_DENIED если его нет.


    * Поскольку для чтения/записи во внешнее хранилище необходимы разрешения, то перед операциями сохранения и записи
     * файла необходимо проверить наличие разрешений. Для этого определен метод checkPermissions(). При установке разрешений
      * срабатывает метод onRequestPermissionsResult(), в котором в случае удачной установки разрешений для переменной
      * permissionGranted задается значение true.
    *Для запроса используется метод ActivityCompat.requestPermissions(Activity activity, String[] permissions, int requestCode).
    * Массив permissions соответственно содержит
    * названия разрешений, которые вы хотите запросить
    *
    *
    * */
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults){
        switch (requestCode){
            case REQUEST_PERMISSION_WRITE:
                if(grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED){
                    permissionGranted = true;
                    Toast.makeText(this, "Разрешения получены", Toast.LENGTH_LONG).show();
                }
                else{
                    Toast.makeText(this, "Необходимо дать разрешения", Toast.LENGTH_LONG).show();
                }
                break;
        }
    }
    //----------------------------Конец записи и чтение во внешнее хранилище------------------------------------

    //-------Сканироваиие сети Wi-fi-------------------------------------------------------------------------
    class ScanReceiver extends BroadcastReceiver {
        private String LOG_TAG = " ";
        @Override     public void onReceive(Context context, Intent intent) {
            WifiManager wifi = (WifiManager) context.getSystemService(WIFI_SERVICE);
            //List scanResultList = wifi.getScanResults();
            List<ScanResult> wifiScanList = wifi.getScanResults();
            wifis = new String[wifiScanList.size()];
            i_w=0;
            for (Object scanResult : wifiScanList){//Мы запускаем цикл по кол-ву элементов в массивах данных. В каждой итерации создаем View-элемент item
                Log.d(LOG_TAG,scanResult.toString());
                // Toast.makeText(context, "click"+scanResult.toString(), Toast.LENGTH_LONG).show(); //Характеристика сети
                //wifis[i] = ((wifiScanList.get(i)).toString());
                wifis[i_w] = ((wifiScanList.get(i_w)).SSID);
                i_w++;
            }
            //Sets the data behind this ListView. The adapter passed to this method may be wrapped by
            // a WrapperListAdapter, depending on the ListView features currently in use. For instance,
            // adding headers and/or footers will cause the adapter to be wrapped.
            //lv.setAdapter(new ArrayAdapter<String>(getApplicationContext(),android.R.layout.simple_spinner_item,wifis));
            // Создаем адаптер ArrayAdapter с помощью массива строк и стандартной разметки элемета spinner
           // ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, wifis);
            ArrayAdapter<String> adapter = new ArrayAdapter<String>(context, android.R.layout.simple_spinner_item, wifis);
            // Определяем разметку для использования при выборе элемента
            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
            // Применяем адаптер к элементу spinner
            lv.setAdapter(adapter);
            //Метод setAdapter() связывает подготовленный список с адаптером.

            context.unregisterReceiver(this);
            Toast.makeText(context, "Number of networks: "+wifiScanList.size(), Toast.LENGTH_LONG).show();//количество сетей
        }
    }

    public void enableWifi() {  //включение модуля
        WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE);
        if (!wifiManager.isWifiEnabled()) {
            wifiManager.setWifiEnabled(true);
            Toast toast = Toast.makeText(getApplicationContext(), "Wifi включен", Toast.LENGTH_SHORT);
            toast.show();
        }
    }

    private void bindToNetwork() {
        final ConnectivityManager connectivityManager = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE);
        final String LOG_TAG = " ";
        /*Класс, который отвечает на запросы о состоянии подключения к сети.
        Он также уведомляет приложения, когда изменяется сетевое подключение.
Основные обязанности этого класса заключаются в следующем:
Мониторинг сетевых подключений (Wi-Fi, GPRS, UMTS и т. Д.)
Отправлять трансляции при изменении сетевых подключений
Попытка «провалиться» в другую сеть при сбое подключения к сети
Предоставьте API, который позволяет приложениям запрашивать крупнозернистые или мелкозернистые состояния доступных сетей
Предоставьте API, который позволяет приложениям запрашивать и выбирать сети для их трафика данных
Экземпляры этого класса должны быть получены с помощью Context.getSystemService (Class)
с аргументом ConnectivityManager.class или Context.getSystemService (String) с аргументом Context.CONNECTIVITY_SERVICE.*/
        NetworkRequest.Builder builder;//Builder используется для создания объектов NetworkRequest. Укажите сетевые функции, необходимые с точки зрения возможностей NetworkCapabilities
        /*NetworkRequest - Определяет запрос для сети, созданный через NetworkRequest.Builder,
        и используется для запроса сети через requestNetwork (NetworkRequest, PendingIntent)
         или прослушивания изменений через registerNetworkCallback (NetworkRequest, PendingIntent).*/
        Log.d(LOG_TAG, "All OK 123 !!!!!!!!!!!!!!!");
        Toast.makeText(this, "All OK !!!!!!!!!!!!!!!", Toast.LENGTH_LONG).show();
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            builder = new NetworkRequest.Builder(); //set the transport type do WIFI
            builder.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);//addTransportType-Добавляет заданный транспортный запрос к этому строителю.
            //int TRANSPORT_WIFI - Indicates this network uses a Wi-Fi transport. - Constant Value: 1 (0x00000001)
            /*
            NetworkCapabilities-Представление возможностей активной сети. Экземпляры обычно получают через onCapabilitiesChanged (Network, NetworkCapabilities)
             или getNetworkCapabilities (Network).
            Это заменяет старый метод выбора TYPE_MOBILE. Вместо того, чтобы указывать на необходимость использования Wi-Fi,
            поскольку для приложения требуется высокая пропускная способность и устаревание рисков, когда появляется новая,
            быстрая сеть (например, LTE), приложение должно указать, что для нее требуется высокая пропускная способность.
            Аналогично, если приложение нуждается в немаршрутизированной сети для массового переноса, оно может указывать на то,
             что вместо того, чтобы предполагать, что все сотовые соединения подключены, и все соединения на основе
              Wi-Fi не являются.
            */

            /*
            You can request an unmetered, high-bandwidth network using the ConnectivityManager.
            With a single network request, you can request an unmetered Wi-Fi or cellular network. When the network is ready
            (e.g., the device's Wi-Fi radio connects to a saved network), the onAvailable() method of your NetworkCallback
             instance is called. If a szuitable network is not found, the onAvailable() method is not called.
             Therefore, you should time-out your request manually; see Waiting for Network Availability.
             */
            connectivityManager.requestNetwork(builder.build(), new ConnectivityManager.NetworkCallback() {

                /*requestNetwork
добавлено в API уровня 21
void requestNetwork (request NetworkRequest, ConnectivityManager.NetworkCallback networkCallback)
Запросите сеть, чтобы удовлетворить набор NetworkCapabilities. Этот NetworkRequest будет работать до выпуска
через unregisterNetworkCallback (NetworkCallback) или вызывается вызывающее приложение. Версия метода, который принимает таймаут,
 - requestNetwork (NetworkRequest, NetworkCallback, int). Состояние запроса может сопровождаться прослушиванием различных
 обратных вызовов, описанных в ConnectivityManager.NetworkCallback. Сеть может использоваться для прямого трафика в сеть.
В настоящее время не поддерживается запрос с сетью с изменяемыми сетевыми возможностями, такими как NET_CAPABILITY_VALIDATED
 или NET_CAPABILITY_CAPTIVE_PORTAL, поскольку эти NetworkCapabilities представляют состояния, которые определенная сеть может
  никогда не достичь, и будет ли сеть достигать этих состояний, неизвестна до начала работы сети, поэтому структура не знать,
   как удовлетворить запросы с этими возможностями.
Этот метод требует, чтобы вызывающий абонент держал либо разрешение CHANGE_NETWORK_STATE, либо возможность изменять параметры
системы, как определено canWrite (Context).

request NetworkRequest: NetworkRequest, описывающий этот запрос.
networkCallback ConnectivityManager.NetworkCallback: ConnectivityManager.NetworkCallback, который будет использоваться для
этого запроса. Обратите внимание, что обратный вызов не должен использоваться совместно - он однозначно определяет этот запрос.
 Обратный вызов активируется во внутреннем обработчике по умолчанию.
*/
                @Override
                public void onAvailable(Network network) {
                           /*
                           *  Когда сеть готова (например, радио Wi-Fi устройства подключается к сохраненной сети),
                           *  вызывается метод onAvailable() вашего экземпляра NetworkCallback. Если подходящая сеть не найдена,
                            *  метод onAvailable() не вызывается. Поэтому вы должны вручную запросить свой запрос; см. «Ожидание
                             *  доступности сети
                           *
                           * */
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                        //      connectivityManager.bindProcessToNetwork(null);
                        //if (barCodeData.getSsid().contains("screenspace")) {
                        connectivityManager.bindProcessToNetwork(network);//Use the Network object to bind the process to it.
                        Log.d(LOG_TAG, "All OK !!!!!!!!!!!!!!!");
                    }
                    else { //This method was deprecated in API level 23
                        //   ConnectivityManager.setProcessDefaultNetwork(null);
                        //if (barCodeData.getSsid().contains("screenspace")) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                            ConnectivityManager.setProcessDefaultNetwork(network);
                        }
                    } //}
                    try {
                        //do a callback or something else to alert your code that it's ok to send the message through socket now
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                        connectivityManager.unregisterNetworkCallback(this);
                    }
                }

            } );
        }
    }

    /*Когда вашему приложению больше не нужна сеть с высокой пропускной способностью, вы должны освободить сеть,
     используя класс ConnectivityManager, чтобы обеспечить возобновление работы платформы с помощью сетевого доступа.


//Вы можете использовать NetworkCallback для захвата объекта сети.
NetworkRequest.Builder builder;
    builder = new NetworkRequest.Builder();
builder.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
    ConnectivityManager connectivityManager = (ConnectivityManager) context.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);
connectivityManager.requestNetwork(builder.build(), new ConnectivityManager.NetworkCallback() {
        @Override
        public void onAvailable(Network network) {
            wifiNetwork = network;
        }
    });
*/
//ДЛя поиска сетей.мПРОВЕРКА.
    class WiFiMonitor extends BroadcastReceiver {//Базовый класс для кода, который принимает и обрабатывает трансляции, отправленные sendBroadcast (Intent).
        // WifiManager wifi;
        private String LOG_TAG = "myWiFiMonitor";
        @Override     public void onReceive(Context context, Intent intent) {//вызывается, когда BroadcastReceiver получает трансляцию Intent.

            String action = intent.getAction();//Применяйте методы getAction() и getData(), чтобы найти действие и данные, связанные с намерением
            //ействие в объекте  Intent устанавливается в методе setAction() и читается методом getAction();
            Log.d(LOG_TAG, action);//считываем действм
            ConnectivityManager cm = (ConnectivityManager)context.getSystemService(CONNECTIVITY_SERVICE);//получаем объект класса ConnectivityManager, который следит за состоянием сети
            //bindToNetwork();
            NetworkInfo activeNetwork = cm.getActiveNetworkInfo();//пПолучаем объект класса NetworkInfo для получения описания состояния сети
            boolean isConnected = activeNetwork != null &&  activeNetwork.isConnectedOrConnecting();//проверяем подключение
            Log.d(LOG_TAG,"isConnected: "+isConnected);
            Toast.makeText(context, "isConnected: "+isConnected, Toast.LENGTH_LONG).show();
            if (!isConnected)
                //bindToNetwork();
                return;
            boolean isWiFi = activeNetwork.getType() == ConnectivityManager.TYPE_WIFI;//проверяем если это Wifi или нет.
            Log.d(LOG_TAG,"isWiFi: "+isWiFi);
            Toast.makeText(context, "isWiFi: "+isWiFi, Toast.LENGTH_LONG).show();
            if (!isWiFi)
                return;
            WifiManager wifiManager = (WifiManager) context.getSystemService(WIFI_SERVICE);
            WifiInfo connectionInfo = wifiManager.getConnectionInfo();
            Log.d(LOG_TAG,connectionInfo.getSSID());
            Toast.makeText(context, "Connected to Internet: "+connectionInfo.getSSID(), Toast.LENGTH_LONG).show();
        }
    }
    //Вызывается при подключении
    private boolean checkSystemWritePermission() { //разрешаем программе вносить изменения
        boolean retVal = true;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            retVal = Settings.System.canWrite(this);
            Log.d(TAG, "Can Write Settings: " + retVal);
            if(retVal){
                Toast.makeText(this, "Write allowed :-)", Toast.LENGTH_LONG).show();
                return (retVal);
            }else{
                Toast.makeText(this, "Write not allowed :-(", Toast.LENGTH_LONG).show();
                // FragmentManager fm = getFragmentManager();
                Intent intent = new Intent(android.provider.Settings.ACTION_MANAGE_WRITE_SETTINGS);
                intent.setData(Uri.parse("package:" + this.getPackageName()));//открывает разрешение
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                //startActivityForResult(intent, WRITE_SETTINGS_REQUEST_CODE);
                //startActivityForResult(intent, MainActivity.MODE);
                //  startActivityForResult(intent, GestureMediaPlayerActivity.CODE_WRITE_SETTINGS_PERMISSION);
                startActivity(intent);
                //  PopupWritePermission dialogFragment = new PopupWritePermission();
                // dialogFragment.show(fm, getString(R.string.popup_writesettings_title));
            }
        }
        return retVal;
    }
    // можно попрбовать использовать нижнюю конструкию, которая подключает по выбору открытой сети. Мне сеть по выбору списка
    void connectToWiFi(String wifiName) {

        WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE);
        WifiConfiguration configuration = new WifiConfiguration();
        //   configuration.SSID = "\"" + wifiName + "\"";
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        wifiManager.addNetwork(configuration);
        List<WifiConfiguration> list = wifiManager.getConfiguredNetworks(); //возвращает список сетей
        for (WifiConfiguration i : list) {
            if (i.SSID != null && i.SSID.equals("\"" + wifiName + "\"")) {
                // Toast.makeText(this, "All OK !!!!!!!!!!!!!!!", Toast.LENGTH_LONG).show();
                wifiManager.disconnect();
                wifiManager.enableNetwork(i.networkId, true);
                wifiManager.reconnect();
            }
        }
    }

    //НА ПРИЕМ
    private class MyClientTask extends AsyncTask<Void, String, Void> {    //AsyncTask - больше для поддержки соединения
        //AsyncTask позволяет выполнить асинхронную работу и делать обновления пользовательского интерфейса.
    /*Для обновления реализуйте метод onPostExecute(), а всю фоновую работу заключите в метод doInBackground().
    После того, как вы реализуете свою собственную задачу, необходимо ее запустить методом execute().*/
        String dstAddress;
        int dstPort;
        String response = "52";
        String t = "+23C" , t1 = "+31C", h = "50%";
        // MyClientTask(){
        //    dstAddress = addr;
        //   dstPort = port;
        //}

        /*Почему-то никто не упомянул про получение результата через get(). Однажды с этим столкнулся, это блокировало основной поток.
         Не делайте так, найдите любой другой способ передать результат, но не через этот зловещий метод ;)*/


        /*1) Метод doInBackGround() выполняется в фоновом потоке, потому доступа к потоку UI внутри данного метода нет.
2) Методы onPostExecute() и onProgressUpdate() выполняются в потоке UI, потому мы можем смело обращаться к нашим компонентам UI.*/
        //Used as handler to cancel task if back button is pressed
        private AsyncTask<Void, String, Void> updateTask = null;
        /*protected void onPreExecute() {
            super.onPreExecute();
            p = new ProgressDialog(MainActivity.this);
            p.setMessage("Please wait...It is downloading");
            p.setIndeterminate(true);
            p.setCancelable(true);
            p.setOnCancelListener(new DialogInterface.OnCancelListener() {
            //updateTask = this;
                @Override
                public void onCancel(DialogInterface dialog) {
                    updateTask.cancel(true);
                    Toast.makeText(MainActivity.this,"AsyncTask is stopped",Toast.LENGTH_LONG).show();
                }
            });
            p.show();
        }*/


        @Override
        protected Void doInBackground(Void... arg0) {
            Socket socket = null;

            try {
                socket = new Socket(SERVERIP, SERVERPORT);
                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(1024);
                byte[] buffer = new byte[1024];
                int bytesRead;
                InputStream inputStream = socket.getInputStream(); // Получаем входные потоки

                /*
     * notice:
     * inputStream.read() will block if no data return
     */

                while ((bytesRead = inputStream.read(buffer)) != -1) { //на прием
                    byteArrayOutputStream.write(buffer, 0, bytesRead);
                    response = byteArrayOutputStream.toString("UTF-8");
                    /*if (revis == 1) {  // Для запроса, т.к. по другому слетает прога
                        String currentString = response; //принимаем строку
                        //String[] separated = currentString.split("=");
                        //t = separated[1];
                        //t1 = separated[2];
                        //h = separated[3];
                    }*/
                    publishProgress(response);//для передачи промежуточных данных методу onProgressUpdate.
                    // выводим промежуточные результаты
                    if (isCancelled() || (FlagCancelled == true)) {
                        FlagCancelled = false;
                        break;
                    }
                    // if (isCancelled()) {
                    //     return null;
                    // }
                    // return null;
                }

                /*вырезка
По моему опыту с AsyncTask , вызов cancel(boolean mayInterruptIfRunning) не обязательно останавливает выполнение фонового процесса.
 Все, что кажется, это то, что AsyncTask будет выполнять onCancelled() и не будет запускаться onPostExecute() когда он будет завершен.
 Поведение, вероятно, зависит от того, какой код у вас есть в doInBackgound()

В моем случае я выполняю запросы сервера с HttpPost, HttpGet и так далее.
Единственный способ, которым я нашел закончить AsyncTask, – это вызвать метод abort (), как вы можете видеть в следующем примере

 if (isCancelled) { try { //cancel the task and immediately abort the HttpRequest uploadTask.cancel(true); post.abort(); }
 catch (UnsupportedOperationException e) { e.printStackTrace(); } } */



                /*Когда мы нажимаем на кнопку "Отменить операцию", то в методе cancel() используем параметр, равный true.
                 В методе doInBackground() при работе цикла идёт проверка отмены (метод isCancelled()).
                  Если приложение видит, что пользователь выбрал отмену задачи, то вместо метода onPostExecute()
                   вызывается метод onCancelled(), в котором и прописываем свою логику кода.
В Android 4.0 появился ещё один метод onCancelled(Void result), способный принимать результат от метода doInBackground().*/




                /*onProgressUpdate – метод получает на вход промежуточные результаты. Сами не вызываем, вместо этого используем
                 метод publishProgress. То, что передаем в publishProgress, попадает в onProgressUpdate.
                Еще имеет смысл пояснить такой момент. Метод onProgressUpdate принимает на вход набор параметров. Мы же в этом уроке передаем ему
                ( через publishProgress) всего одно значение. Поэтому чтобы прочесть это значение мы берем первый элемент массива ([0]).*/

            } catch (UnknownHostException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                response = "UnknownHostException: " + e.toString();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                response = "IOException: " + e.toString();
            }finally{
                if(socket != null){
                    try {
                        socket.close();
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }
            return null;
        }

        protected void onProgressUpdate(String... values) {
            super.onProgressUpdate(values);
            outputText.setText(values[0]);
            /*if (revis == 1) {
                ResponseT.setText(values[0]);
                ResponseT1.setText(values[0]);
                ResponseH.setText(values[0]);
            }*/

        }


        @Override
        protected void onPostExecute(Void result) {// последний метод выполняется по окончанию doInBackground.
            outputText.setText(response);
            /*if (revis == 1) {
                ResponseT.setText(t);
                ResponseT1.setText(t1);
                ResponseH.setText(h);
            }*/
            super.onPostExecute(result);

        }
    }

// Использотание

    /*Поточно - ориентированная реализация
    фоновая операция выполняется из отдельного потока, а ImageView всегда управляется из потока пользовательского интерфейса.

Однако, по мере того, как усложняется операция, этот вид кода может усложниться и его трудно поддерживать.
Чтобы обрабатывать более сложные взаимодействия с рабочим потоком, вы можете рассмотреть возможность использования
обработчика в своем рабочем потоке для обработки сообщений, доставляемых из потока пользовательского интерфейса.
Посмотрите Threading на Android для полного объяснения того, как запланировать работу над фоновыми потоками и связаться
с потоком пользовательского интерфейса.
Потокобезопасные методы
В некоторых ситуациях реализуемые вами методы могут вызываться из более чем одного потока и поэтому должны быть написаны так,
 чтобы быть потокобезопасными.

Это в первую очередь относится к методам, которые можно вызывать удаленно, например к методам в связанной службе.
Когда вызов метода, реализованного в IBinder, происходит в том же процессе, в котором работает IBinder, метод выполняется
 в потоке вызывающего. Однако, когда вызов происходит в другом процессе, метод выполняется в потоке, выбранном из пула
 потоков, который система поддерживает в том же процессе, что и IBinder (он не выполняется в потоке пользовательского интерфейса
  процесса). Например, если метод onBind () службы будет вызываться из потока пользовательского интерфейса процесса службы,
  методы, реализованные в объекте, который возвращает onBind () (например, подкласс, реализующий методы RPC),
  будут вызываться из потоков в бассейн. Поскольку служба может иметь более одного клиента, несколько потоков пула
   могут одновременно использовать один и тот же метод IBinder. Поэтому методы IBinder должны быть реализованы,
   чтобы быть потокобезопасными.

Аналогично, поставщик контента может получать запросы данных, которые исходят из других процессов. Хотя классы ContentResolver
 и ContentProvider скрывают подробности управления межпроцессным взаимодействием, методы ContentProvider, отвечающие
 на эти запросы - методы query (), insert (), delete (), update () и getType () - вызываются из пула потоков в
  процессе провайдера контента, а не из потока пользовательского интерфейса для процесса. Поскольку эти методы могут
   вызываться из любого числа потоков одновременно, они также должны быть реализованы для обеспечения безопасности потоков.


    */
    class MyRunnable implements Runnable {
        private String SERVERIP;
        private int SERVERPORT;
        private long sum;
        private long thread;

        String response = "Empty!";


        //sock = new Socket("192.168.1.2", 4444);

        MyRunnable(java.lang.String SERVERIP, int SERVERPORT) {
            this.SERVERIP = SERVERIP;
            this.SERVERPORT = SERVERPORT;

        }


        @Override


        public void run() {

            thread = Thread.currentThread().getId();
    //            Socket socket = null;

            try {
                socket = new Socket(SERVERIP, SERVERPORT);
                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(1024);
                byte[] buffer = new byte[1024];
                int bytesRead;
                InputStream inputStream = socket.getInputStream();

                while ((bytesRead = inputStream.read(buffer)) != -1) { //на прием
                    byteArrayOutputStream.reset();
                    byteArrayOutputStream.write(buffer, 0, bytesRead);
                    response = byteArrayOutputStream.toString("UTF-8");
                    //onTaskCompleted(response,jsoncode);
                    outputText.post(new Runnable() {
                        @Override
                        public void run() {
                            //tv.setText(tv.getText() + " задача # " + number + ". сумма: " + sum + ", поток # "
                            //      + thread + "\n");
                            outputText.setText(response);
                            // Если вдруг пришол неполный ответ, чтоб не п\покрашилось приложение дописываем
                         //   response = response + ",End:0}";
                            onTaskCompleted(response,jsoncode);
                        }
                    });

                }
                //socket.close();

            } catch (UnknownHostException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                response = "UnknownHostException: " + e.toString();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                response = "IOException: " + e.toString();
            }finally{
                if(socket != null){
                    try {
                        socket.close();
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }





            outputText.post(new Runnable() {
                @Override
                public void run() {
                    //tv.setText(tv.getText() + " задача # " + number + ". сумма: " + sum + ", поток # "
                      //      + thread + "\n");
                    outputText.setText(response);
                }
            });

            try {
                sleep(500);
            } catch (InterruptedException ignored) {

            }


        }
    }

    class AnotherThread extends Thread {

        AnotherThread() {
            start();
        }

        @Override
        public void run() {
            // пул рассчитан на 5 потоков
            ExecutorService executor = Executors.newFixedThreadPool(1);

            // всего необходимо выполнить 31 задачу
           // for (int i = 0; i < 31; i++) {
                // каждый поток должен посчитать сумму всех чисел
                // в диапазоне от 0 до 40 миллионов
                Runnable worker = new MyRunnable(SERVERIP, SERVERPORT);
                executor.execute(worker); // добавляем поток в пул
            //}

            executor.shutdown(); // новые задачи после этого уже нельзя добавить
            // executor.shutdownNow(); // немедленно прекратить выполнение всех задач

            // подождать немного, пока все задачи будут выполнены
            try {
                executor.awaitTermination(1, TimeUnit.DAYS);
            } catch (InterruptedException ignored) {

            }
            tv.post(new Runnable() {
                @Override
                public void run() {
                    //tv.setText(tv.getText() + "Всё готово!\n");
                    outputText.setText("Stop!\n");
                }
            });
        }
    }


    protected void onStop() { //для остановки потока
        revis = 0;
        FlagCancelled = true;
        super.onStop();
    }

    private void onOpenClick()
    {
        // Создание подключения
        mConnect = new Connection(HOST, PORT);
        // Открытие сокета в отдельном потоке
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    mConnect.openConnection();
                    // Разблокирование кнопок в UI потоке
                   // runOnUiThread(new Runnable() {
                    //    @Override
                    //    public void run() {
                    //        mBtnSend.setEnabled(true);
                    //        mBtnClose.setEnabled(true);
                      //  }
                    //});
                    Log.d(Connection.LOG_TAG, "Соединение установлено");
                    Log.d(Connection.LOG_TAG, "(mConnect != null) = " + (mConnect != null));
                } catch (Exception e) {
                    Log.e(Connection.LOG_TAG, e.getMessage());
                    mConnect = null;
                }
            }
        }).start();
    }


    /**  * Метод для закрытия сокета, по которому мы общались.  */
    public void closeConnection() {
        /* Проверяем сокет. Если он не зарыт, то закрываем его и освобдождаем соединение.*/
        if (socket != null && !socket.isClosed()) {
            try {
                socket.close();
            } catch (IOException e) {
                Log.e(TAG, "Невозможно закрыть сокет: " + e.getMessage());
            } finally {
                socket = null;
            }
        }     socket = null; }
    protected void finalize() throws Throwable
    {
        super.finalize();
        closeConnection();
    }

}
